name: Security Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  GO_VERSION: '1.25'
  NODE_VERSION: '22'

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      go-version: ${{ steps.versions.outputs.go-version }}
      node-version: ${{ steps.versions.outputs.node-version }}
    steps:
      - name: Set versions
        id: versions
        run: |
          echo "go-version=${{ env.GO_VERSION }}" >> $GITHUB_OUTPUT
          echo "node-version=${{ env.NODE_VERSION }}" >> $GITHUB_OUTPUT

  backend-build:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ needs.setup.outputs.go-version }}

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Build Go services
        run: |
          echo "Backend build step - Go services will be built here"
          echo "Current directory structure created for future Go services"

  frontend-build:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ needs.setup.outputs.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          echo "Frontend build step - Node.js dependencies will be installed here"
          echo "Dashboard application structure created for future React development"

      - name: Build frontend
        run: |
          echo "Frontend React dashboard will be built here"

  vulnerability-scanning:
    runs-on: ubuntu-latest
    needs: [backend-build, frontend-build]
    permissions:
      security-events: write
      packages: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build vulnerable demo container
        run: |
          docker build -t vulnerable-demo:latest examples/vulnerable-app/
          echo "Built vulnerable demo container for scanning"

      - name: Run Trivy scanner
        id: trivy-scan
        run: |
          echo "Running Trivy vulnerability scan..."
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v "${{ github.workspace }}":/workspace \
            aquasec/trivy:latest image \
            --format json \
            --output /workspace/trivy-results.json \
            vulnerable-demo:latest
          echo "Trivy scan completed"
        continue-on-error: true

      - name: Run Grype scanner
        id: grype-scan
        run: |
          echo "Running Grype vulnerability scan..."
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
          grype vulnerable-demo:latest \
            -o json \
            --file grype-results.json
          echo "Grype scan completed"
        continue-on-error: true

      - name: Parse vulnerability counts
        id: parse-results
        run: |
          echo "Parsing vulnerability results..."

          # Parse Trivy results
          if [[ -f trivy-results.json ]]; then
            trivy_critical=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' trivy-results.json 2>/dev/null || echo "0")
            trivy_high=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' trivy-results.json 2>/dev/null || echo "0")
            trivy_medium=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "MEDIUM")] | length' trivy-results.json 2>/dev/null || echo "0")
            trivy_low=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "LOW")] | length' trivy-results.json 2>/dev/null || echo "0")
            trivy_total=$((trivy_critical + trivy_high + trivy_medium + trivy_low))
          else
            trivy_critical=0; trivy_high=0; trivy_medium=0; trivy_low=0; trivy_total=0
          fi

          # Parse Grype results
          if [[ -f grype-results.json ]]; then
            grype_critical=$(jq '[.matches[]? | select(.vulnerability.severity == "Critical")] | length' grype-results.json 2>/dev/null || echo "0")
            grype_high=$(jq '[.matches[]? | select(.vulnerability.severity == "High")] | length' grype-results.json 2>/dev/null || echo "0")
            grype_medium=$(jq '[.matches[]? | select(.vulnerability.severity == "Medium")] | length' grype-results.json 2>/dev/null || echo "0")
            grype_low=$(jq '[.matches[]? | select(.vulnerability.severity == "Low")] | length' grype-results.json 2>/dev/null || echo "0")
            grype_total=$((grype_critical + grype_high + grype_medium + grype_low))
          else
            grype_critical=0; grype_high=0; grype_medium=0; grype_low=0; grype_total=0
          fi

          # Output to GitHub Actions summary
          {
            echo "# Security Pipeline Results"
            echo ""
            echo "## Vulnerability Scan Results"
            echo "| Scanner | Critical | High | Medium | Low | Total |"
            echo "|---------|----------|------|--------|-----|-------|"
            echo "| **Trivy** | $trivy_critical | $trivy_high | $trivy_medium | $trivy_low | **$trivy_total** |"
            echo "| **Grype** | $grype_critical | $grype_high | $grype_medium | $grype_low | **$grype_total** |"
            echo ""
            echo "## SBOM Generation Results"
            echo "| Format | Components/Packages | Validation | Status |"
            echo "|---------|----------|------|-------|"
            cyclonedx_validation=$([ "${{ steps.validate-sbom.outputs.validation_errors }}" = "0" ] && echo "PASS" || echo "FAIL")
            spdx_validation=$([ "${{ steps.validate-sbom.outputs.validation_errors }}" = "0" ] && echo "PASS" || echo "FAIL")
            cyclonedx_status=$([ "${{ steps.sbom-cyclonedx.outcome }}" = "success" ] && echo "Generated" || echo "Failed")
            spdx_status=$([ "${{ steps.sbom-spdx.outcome }}" = "success" ] && echo "Generated" || echo "Failed")
            echo "| **CycloneDX** | ${{ steps.parse-sbom.outputs.cyclonedx_components }} components | $cyclonedx_validation | $cyclonedx_status |"
            echo "| **SPDX** | ${{ steps.parse-sbom.outputs.spdx_packages }} packages | $spdx_validation | $spdx_status |"
            echo ""
            echo "## SBOM Metadata"
            echo "- **Target**: vulnerable-demo:latest container"
            echo "- **Scope**: All container layers included"
            echo "- **CycloneDX Component**: ${{ steps.parse-sbom.outputs.cyclonedx_metadata }}"
            echo "- **SPDX Document**: ${{ steps.parse-sbom.outputs.spdx_name }}"
            echo "- **Unique Licenses**: ${{ steps.parse-sbom.outputs.cyclonedx_licenses }}"
            echo "- **SPDX Relationships**: ${{ steps.parse-sbom.outputs.spdx_relationships }}"
            echo ""
            echo "## SBOM Container Registry References"
            if [[ "${{ steps.upload-cyclonedx.outcome }}" == "success" ]]; then
              echo "- **CycloneDX SBOM**: \`${{ steps.upload-cyclonedx.outputs.cyclonedx_registry_ref }}\`"
            else
              echo "- **CycloneDX SBOM**: Upload failed"
            fi
            if [[ "${{ steps.upload-spdx.outcome }}" == "success" ]]; then
              echo "- **SPDX SBOM**: \`${{ steps.upload-spdx.outputs.spdx_registry_ref }}\`"
            else
              echo "- **SPDX SBOM**: Upload failed"
            fi
            echo ""
            echo "## Artifact Downloads"
            echo "- [CycloneDX SBOM](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (sbom-cyclonedx artifact)"
            echo "- [SPDX SBOM](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (sbom-spdx artifact)"
            echo "- [Trivy Results](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (trivy-vulnerability-results artifact)"
            echo "- [Grype Results](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (grype-vulnerability-results artifact)"
            echo ""
            echo "## Scan Details"
            echo "- **OS Packages**: Scanned for known vulnerabilities"
            echo "- **Dependencies**: Go modules and application dependencies analyzed"
            echo "- **Base Image**: Container base image vulnerabilities detected"
          } >> $GITHUB_STEP_SUMMARY

          echo "Vulnerability count parsing completed"

      - name: Upload Trivy results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: trivy-vulnerability-results
          path: trivy-results.json
          retention-days: 30

      - name: Upload Grype results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: grype-vulnerability-results
          path: grype-results.json
          retention-days: 30

      - name: Install Syft SBOM generator
        run: |
          echo "Installing Syft for SBOM generation..."
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          syft version
          echo "Syft installation completed"

      - name: Generate SBOM in CycloneDX format
        id: sbom-cyclonedx
        run: |
          echo "Generating CycloneDX SBOM for vulnerable-demo:latest..."
          syft vulnerable-demo:latest \
            --scope all-layers \
            -o cyclonedx-json=sbom-cyclonedx.json \
            -v
          echo "CycloneDX SBOM generation completed"
        continue-on-error: true

      - name: Generate SBOM in SPDX format
        id: sbom-spdx
        run: |
          echo "Generating SPDX SBOM for vulnerable-demo:latest..."
          syft vulnerable-demo:latest \
            --scope all-layers \
            -o spdx-json=sbom-spdx.json \
            -v
          echo "SPDX SBOM generation completed"
        continue-on-error: true

      - name: Install SBOM validation tools
        run: |
          echo "Installing SBOM validation tools..."
          # Install CycloneDX CLI for validation
          npm install -g @cyclonedx/cyclonedx-cli
          # Install SPDX tools for validation
          pip install spdx-tools
          echo "SBOM validation tools installed"

      - name: Validate SBOM formats
        id: validate-sbom
        run: |
          echo "Validating SBOM format compliance..."
          validation_errors=0
          
          # Validate CycloneDX SBOM
          if [[ -f sbom-cyclonedx.json ]]; then
            echo "Validating CycloneDX SBOM format..."
            if cyclonedx-cli validate --input-file sbom-cyclonedx.json; then
              echo "PASS: CycloneDX SBOM validation passed"
            else
              echo "FAIL: CycloneDX SBOM validation failed"
              validation_errors=$((validation_errors + 1))
            fi
          else
            echo "FAIL: CycloneDX SBOM file not found"
            validation_errors=$((validation_errors + 1))
          fi
          
          # Validate SPDX SBOM
          if [[ -f sbom-spdx.json ]]; then
            echo "Validating SPDX SBOM format..."
            if spdx-tools-convert sbom-spdx.json; then
              echo "PASS: SPDX SBOM validation passed"
            else
              echo "FAIL: SPDX SBOM validation failed"
              validation_errors=$((validation_errors + 1))
            fi
          else
            echo "FAIL: SPDX SBOM file not found"
            validation_errors=$((validation_errors + 1))
          fi
          
          echo "validation_errors=$validation_errors" >> $GITHUB_OUTPUT
          
          if [[ $validation_errors -eq 0 ]]; then
            echo "PASS: All SBOM validations passed"
          else
            echo "FAIL: $validation_errors SBOM validation(s) failed"
          fi
        continue-on-error: true

      - name: Parse SBOM metadata
        id: parse-sbom
        run: |
          echo "Parsing SBOM metadata for summary..."
          
          # Parse CycloneDX SBOM
          if [[ -f sbom-cyclonedx.json ]]; then
            cyclonedx_components=$(jq '.components | length' sbom-cyclonedx.json 2>/dev/null || echo "0")
            cyclonedx_metadata=$(jq -r '.metadata.component.name // "N/A"' sbom-cyclonedx.json 2>/dev/null || echo "N/A")
            cyclonedx_licenses=$(jq '[.components[].licenses[]?.license.name // empty] | unique | length' sbom-cyclonedx.json 2>/dev/null || echo "0")
          else
            cyclonedx_components=0; cyclonedx_metadata="N/A"; cyclonedx_licenses=0
          fi
          
          # Parse SPDX SBOM
          if [[ -f sbom-spdx.json ]]; then
            spdx_packages=$(jq '.packages | length' sbom-spdx.json 2>/dev/null || echo "0")
            spdx_name=$(jq -r '.name // "N/A"' sbom-spdx.json 2>/dev/null || echo "N/A")
            spdx_relationships=$(jq '.relationships | length' sbom-spdx.json 2>/dev/null || echo "0")
          else
            spdx_packages=0; spdx_name="N/A"; spdx_relationships=0
          fi
          
          echo "cyclonedx_components=$cyclonedx_components" >> $GITHUB_OUTPUT
          echo "cyclonedx_metadata=$cyclonedx_metadata" >> $GITHUB_OUTPUT
          echo "cyclonedx_licenses=$cyclonedx_licenses" >> $GITHUB_OUTPUT
          echo "spdx_packages=$spdx_packages" >> $GITHUB_OUTPUT
          echo "spdx_name=$spdx_name" >> $GITHUB_OUTPUT
          echo "spdx_relationships=$spdx_relationships" >> $GITHUB_OUTPUT

      - name: Upload CycloneDX SBOM
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: sbom-cyclonedx
          path: sbom-cyclonedx.json
          retention-days: 30

      - name: Upload SPDX SBOM
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: sbom-spdx
          path: sbom-spdx.json
          retention-days: 30

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install ORAS for OCI artifact uploads
        run: |
          echo "Installing ORAS for OCI artifact management..."
          curl -LO https://github.com/oras-project/oras/releases/latest/download/oras_linux_amd64.tar.gz
          mkdir -p oras-install/
          tar -zxf oras_linux_amd64.tar.gz -C oras-install/
          sudo mv oras-install/oras /usr/local/bin/
          rm -rf oras-install oras_linux_amd64.tar.gz
          oras version
          echo "ORAS installation completed"

      - name: Upload CycloneDX SBOM to Container Registry
        id: upload-cyclonedx
        run: |
          echo "Uploading CycloneDX SBOM to GitHub Container Registry..."
          IMAGE_REF="ghcr.io/${{ github.repository_owner }}/$(echo '${{ github.repository }}' | cut -d'/' -f2)"
          SBOM_REF="${IMAGE_REF}/sbom:cyclonedx-${{ github.sha }}"
          
          if [[ -f sbom-cyclonedx.json ]]; then
            oras push "$SBOM_REF" \
              --annotation "org.opencontainers.image.title=CycloneDX SBOM" \
              --annotation "org.opencontainers.image.description=Software Bill of Materials in CycloneDX format" \
              --annotation "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
              --annotation "org.opencontainers.image.revision=${{ github.sha }}" \
              --annotation "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
              --annotation "sbom.format=cyclonedx" \
              --annotation "sbom.version=1.6" \
              --annotation "target.image=vulnerable-demo:latest" \
              sbom-cyclonedx.json:application/vnd.cyclonedx+json
            echo "cyclonedx_registry_ref=$SBOM_REF" >> $GITHUB_OUTPUT
            echo "CycloneDX SBOM uploaded successfully to $SBOM_REF"
          else
            echo "FAIL: CycloneDX SBOM file not found for upload"
            exit 1
          fi
        continue-on-error: true

      - name: Upload SPDX SBOM to Container Registry
        id: upload-spdx
        run: |
          echo "Uploading SPDX SBOM to GitHub Container Registry..."
          IMAGE_REF="ghcr.io/${{ github.repository_owner }}/$(echo '${{ github.repository }}' | cut -d'/' -f2)"
          SBOM_REF="${IMAGE_REF}/sbom:spdx-${{ github.sha }}"
          
          if [[ -f sbom-spdx.json ]]; then
            oras push "$SBOM_REF" \
              --annotation "org.opencontainers.image.title=SPDX SBOM" \
              --annotation "org.opencontainers.image.description=Software Bill of Materials in SPDX format" \
              --annotation "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
              --annotation "org.opencontainers.image.revision=${{ github.sha }}" \
              --annotation "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
              --annotation "sbom.format=spdx" \
              --annotation "sbom.version=2.3" \
              --annotation "target.image=vulnerable-demo:latest" \
              spdx-sbom.json:application/spdx+json
            echo "spdx_registry_ref=$SBOM_REF" >> $GITHUB_OUTPUT
            echo "SPDX SBOM uploaded successfully to $SBOM_REF"
          else
            echo "FAIL: SPDX SBOM file not found for upload"
            exit 1
          fi
        continue-on-error: true

      - name: Verify SBOM uploads
        run: |
          echo "Verifying SBOM uploads to Container Registry..."
          upload_errors=0
          
          # Check CycloneDX upload
          if [[ "${{ steps.upload-cyclonedx.outcome }}" == "success" ]]; then
            echo "PASS: CycloneDX SBOM uploaded to registry"
            echo "Registry reference: ${{ steps.upload-cyclonedx.outputs.cyclonedx_registry_ref }}"
          else
            echo "FAIL: CycloneDX SBOM upload failed"
            upload_errors=$((upload_errors + 1))
          fi
          
          # Check SPDX upload
          if [[ "${{ steps.upload-spdx.outcome }}" == "success" ]]; then
            echo "PASS: SPDX SBOM uploaded to registry"
            echo "Registry reference: ${{ steps.upload-spdx.outputs.spdx_registry_ref }}"
          else
            echo "FAIL: SPDX SBOM upload failed"
            upload_errors=$((upload_errors + 1))
          fi
          
          if [[ $upload_errors -eq 0 ]]; then
            echo "PASS: All SBOM uploads completed successfully"
          else
            echo "FAIL: $upload_errors SBOM upload(s) failed"
          fi

      - name: Check scanner failures
        run: |
          trivy_exit=${{ steps.trivy-scan.outcome }}
          grype_exit=${{ steps.grype-scan.outcome }}

          if [[ "$trivy_exit" != "success" && "$grype_exit" != "success" ]]; then
            echo "Both scanners failed - workflow will fail"
            exit 1
          elif [[ "$trivy_exit" != "success" ]]; then
            echo " Trivy scanner failed, but Grype succeeded"
          elif [[ "$grype_exit" != "success" ]]; then
            echo " Grype scanner failed, but Trivy succeeded"
          else
            echo " Both scanners completed successfully"
          fi

  keyless-signing:
    runs-on: ubuntu-latest
    needs: [vulnerability-scanning]
    permissions:
      id-token: write
      contents: read
      packages: write
    env:
      COSIGN_EXPERIMENTAL: 1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Cosign CLI
        id: install-cosign
        run: |
          echo "Installing Cosign CLI v2.2.3..."
          COSIGN_VERSION="v2.2.3"
          COSIGN_BINARY="cosign-linux-amd64"
          COSIGN_URL="https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/${COSIGN_BINARY}"
          COSIGN_CHECKSUM_URL="https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign_checksums.txt"

          # Download Cosign binary and checksums
          curl -sSL "$COSIGN_URL" -o cosign
          curl -sSL "$COSIGN_CHECKSUM_URL" -o cosign_checksums.txt

          # Verify checksum for security
          EXPECTED_CHECKSUM=$(grep "$COSIGN_BINARY" cosign_checksums.txt | cut -d' ' -f1)
          ACTUAL_CHECKSUM=$(sha256sum cosign | cut -d' ' -f1)

          if [[ "$EXPECTED_CHECKSUM" != "$ACTUAL_CHECKSUM" ]]; then
            echo "SIGN_011: Cosign checksum verification failed"
            echo "Expected: $EXPECTED_CHECKSUM"
            echo "Actual: $ACTUAL_CHECKSUM"
            exit 1
          fi

          # Install Cosign
          chmod +x cosign
          sudo mv cosign /usr/local/bin/cosign

          # Verify installation
          cosign version
          echo "Cosign CLI v2.2.3 installed successfully with checksum verification"

      - name: Configure and test GitHub OIDC token
        id: test-oidc
        run: |
          echo "Configuring and testing GitHub OIDC token for Sigstore..."

          # Test OIDC token environment variables
          echo "Testing GitHub OIDC token environment..."
          if [[ -z "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ]]; then
            echo "SIGN_001: OIDC token request token not available"
            exit 1
          fi

          if [[ -z "$ACTIONS_ID_TOKEN_REQUEST_URL" ]]; then
            echo "SIGN_002: OIDC token request URL not available"
            exit 1
          fi

          # Configure OIDC claims for Sigstore
          echo "Configuring OIDC claims for identity verification..."

          # Set issuer and audience for Sigstore
          OIDC_ISSUER="https://token.actions.githubusercontent.com"
          OIDC_AUDIENCE="sigstore"

          # Test OIDC token acquisition
          echo "Testing OIDC token acquisition..."
          OIDC_TOKEN=$(curl -sH "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
                           "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=$OIDC_AUDIENCE" | \
                           jq -r '.value' 2>/dev/null)

          if [[ -z "$OIDC_TOKEN" || "$OIDC_TOKEN" == "null" ]]; then
            echo "SIGN_003: OIDC token acquisition failed"
            exit 1
          fi

          # Validate token claims
          echo "Validating OIDC token claims..."
          TOKEN_HEADER=$(echo "$OIDC_TOKEN" | cut -d'.' -f1)
          TOKEN_PAYLOAD=$(echo "$OIDC_TOKEN" | cut -d'.' -f2)

          # Decode and validate payload (add padding if needed)
          PADDED_PAYLOAD=$(echo "$TOKEN_PAYLOAD" | sed 's/$/===/' | fold -w 4 | head -1)
          TOKEN_CLAIMS=$(echo "$PADDED_PAYLOAD" | base64 -d 2>/dev/null | jq . 2>/dev/null || echo "{}")

          # Extract and validate key claims
          ISS=$(echo "$TOKEN_CLAIMS" | jq -r '.iss // empty')
          AUD=$(echo "$TOKEN_CLAIMS" | jq -r '.aud // empty')
          SUB=$(echo "$TOKEN_CLAIMS" | jq -r '.sub // empty')
          ACTOR=$(echo "$TOKEN_CLAIMS" | jq -r '.actor // empty')
          REPOSITORY=$(echo "$TOKEN_CLAIMS" | jq -r '.repository // empty')

          echo "OIDC Token Claims:"
          echo "  Issuer (iss): $ISS"
          echo "  Audience (aud): $AUD"
          echo "  Subject (sub): $SUB"
          echo "  Actor: $ACTOR"
          echo "  Repository: $REPOSITORY"

          # Validate required claims
          if [[ "$ISS" != "$OIDC_ISSUER" ]]; then
            echo "SIGN_004: Invalid OIDC issuer claim"
            exit 1
          fi

          if [[ "$AUD" != "$OIDC_AUDIENCE" ]]; then
            echo "SIGN_005: Invalid OIDC audience claim"
            exit 1
          fi

          if [[ -z "$SUB" ]]; then
            echo "SIGN_006: Missing OIDC subject claim"
            exit 1
          fi

          # Set environment variables for downstream steps
          echo "OIDC_TOKEN_VERIFIED=true" >> $GITHUB_ENV
          echo "OIDC_ISSUER=$OIDC_ISSUER" >> $GITHUB_ENV
          echo "OIDC_AUDIENCE=$OIDC_AUDIENCE" >> $GITHUB_ENV
          echo "OIDC_SUBJECT=$SUB" >> $GITHUB_ENV

          echo "PASS: OIDC token configuration and validation completed"
          echo "Identity verified: $SUB"

      - name: Test Cosign with OIDC integration
        id: test-cosign
        run: |
          echo "Testing Cosign CLI with OIDC integration..."

          # Test Cosign version and help
          echo "Testing Cosign CLI functionality..."
          cosign version

          # Test OIDC integration
          echo "Testing Cosign OIDC integration..."
          echo "COSIGN_EXPERIMENTAL: $COSIGN_EXPERIMENTAL"
          echo "OIDC verified: $OIDC_TOKEN_VERIFIED"
          echo "OIDC issuer: $OIDC_ISSUER"
          echo "OIDC audience: $OIDC_AUDIENCE"
          echo "OIDC subject: $OIDC_SUBJECT"

          # Verify Cosign can access OIDC token
          if [[ "$OIDC_TOKEN_VERIFIED" != "true" ]]; then
            echo "SIGN_007: OIDC token not verified for Cosign"
            exit 1
          fi

          echo "PASS: Cosign CLI ready for keyless signing with OIDC identity"
          echo "Signing identity: $OIDC_SUBJECT"

      - name: Prepare demo container for signing
        id: prepare-container
        run: |
          echo "Preparing vulnerable demo container for signing tests..."

          # Build the demo container for signing
          docker build -t vulnerable-demo:signing-test examples/vulnerable-app/

          # Get container digest for signing
          CONTAINER_DIGEST=$(docker inspect vulnerable-demo:signing-test --format='{{index .RepoDigests 0}}' 2>/dev/null || echo "")

          if [[ -z "$CONTAINER_DIGEST" ]]; then
            # For local images without repo digests, use image ID
            CONTAINER_ID=$(docker inspect vulnerable-demo:signing-test --format='{{.Id}}')
            echo "container_target=vulnerable-demo:signing-test@$CONTAINER_ID" >> $GITHUB_OUTPUT
            echo "Container prepared for signing: vulnerable-demo:signing-test@$CONTAINER_ID"
          else
            echo "container_target=$CONTAINER_DIGEST" >> $GITHUB_OUTPUT
            echo "Container prepared for signing: $CONTAINER_DIGEST"
          fi

      - name: Implement keyless signing for container images
        id: keyless-signing
        run: |
          echo "Implementing keyless signing for container images..."

          # Get container target from previous step
          CONTAINER_TARGET="${{ steps.prepare-container.outputs.container_target }}"

          if [[ -z "$CONTAINER_TARGET" ]]; then
            echo "SIGN_021: Container target not resolved"
            exit 1
          fi

          echo "Signing target: $CONTAINER_TARGET"
          echo "Signing identity: $OIDC_SUBJECT"

          # Configure signing metadata and annotations
          echo "Configuring signing metadata and annotations..."

          SIGNING_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          WORKFLOW_REF="${{ github.workflow }}@${{ github.ref }}"
          COMMIT_SHA="${{ github.sha }}"

          # Create signing annotations
          ANNOTATIONS=(
            "--annotation=org.opencontainers.image.title=Vulnerable Demo Container"
            "--annotation=org.opencontainers.image.description=Demo container for security scanning"
            "--annotation=org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}"
            "--annotation=org.opencontainers.image.revision=$COMMIT_SHA"
            "--annotation=org.opencontainers.image.created=$SIGNING_TIME"
            "--annotation=keystone.signature.workflow=$WORKFLOW_REF"
            "--annotation=keystone.signature.actor=${{ github.actor }}"
            "--annotation=keystone.signature.repository=${{ github.repository }}"
            "--annotation=keystone.signature.type=keyless"
          )

          # Perform keyless signing using GitHub OIDC identity
          echo "Performing keyless signing with Cosign..."

          if cosign sign --yes "${ANNOTATIONS[@]}" "$CONTAINER_TARGET"; then
            echo "PASS: Container image signed successfully"
            echo "Signature created with OIDC identity: $OIDC_SUBJECT"
            echo "Signed at: $SIGNING_TIME"
            echo "Container: $CONTAINER_TARGET"

            # Store signing results
            echo "container_signed=true" >> $GITHUB_OUTPUT
            echo "signing_time=$SIGNING_TIME" >> $GITHUB_OUTPUT
            echo "signed_identity=$OIDC_SUBJECT" >> $GITHUB_OUTPUT
          else
            echo "SIGN_031: Keyless signing process failed"
            exit 1
          fi

      - name: Verify container signature
        id: verify-signature
        run: |
          echo "Verifying container signature immediately after signing..."

          CONTAINER_TARGET="${{ steps.prepare-container.outputs.container_target }}"

          # Verify signature with identity verification
          echo "Verifying signature with identity: $OIDC_SUBJECT"

          if cosign verify \
              --certificate-identity="$OIDC_SUBJECT" \
              --certificate-oidc-issuer="$OIDC_ISSUER" \
              "$CONTAINER_TARGET"; then
            echo "PASS: Container signature verified successfully"
            echo "Signature verified for identity: $OIDC_SUBJECT"
            echo "signature_verified=true" >> $GITHUB_OUTPUT
          else
            echo "SIGN_051: Signature verification failed"
            exit 1
          fi

      - name: Configure Rekor transparency log integration
        id: rekor-integration
        run: |
          echo "Configuring Rekor transparency log integration..."

          # Configure Rekor transparency log endpoint
          REKOR_URL="https://rekor.sigstore.dev"
          echo "Rekor transparency log endpoint: $REKOR_URL"

          # Install Rekor CLI for log operations
          echo "Installing Rekor CLI for log entry operations..."
          REKOR_VERSION="v1.3.6"
          REKOR_BINARY="rekor-cli-linux-amd64"
          REKOR_CLI_URL="https://github.com/sigstore/rekor/releases/download/${REKOR_VERSION}/${REKOR_BINARY}"

          curl -sSL "$REKOR_CLI_URL" -o rekor-cli
          chmod +x rekor-cli
          sudo mv rekor-cli /usr/local/bin/rekor-cli

          # Test Rekor CLI installation
          rekor-cli version
          echo "Rekor CLI installed successfully"

          # Configure Rekor connection settings
          echo "REKOR_URL=$REKOR_URL" >> $GITHUB_ENV
          echo "rekor_endpoint_configured=true" >> $GITHUB_OUTPUT

      - name: Capture and verify Rekor log entries
        id: rekor-verification
        run: |
          echo "Capturing and verifying Rekor transparency log entries..."

          CONTAINER_TARGET="${{ steps.prepare-container.outputs.container_target }}"

          # Search for log entries related to our signature
          echo "Searching for transparency log entries..."

          # Get the public key used for verification
          PUBLIC_KEY_PEM=$(cosign verify \
              --certificate-identity="$OIDC_SUBJECT" \
              --certificate-oidc-issuer="$OIDC_ISSUER" \
              "$CONTAINER_TARGET" 2>/dev/null | \
              jq -r '.[0].optional.Bundle.Payload.body' | \
              base64 -d | jq -r '.spec.signature.publicKey.content' || echo "")

          if [[ -z "$PUBLIC_KEY_PEM" ]]; then
            echo "SIGN_041: Could not extract public key from signature"
            exit 1
          fi

          # Search Rekor for entries by public key
          echo "Searching Rekor for log entries..."

          # Create temporary file for public key
          echo "$PUBLIC_KEY_PEM" > /tmp/pub_key.pem

          # Search for log entries
          LOG_ENTRIES=$(rekor-cli search --public-key /tmp/pub_key.pem --format json 2>/dev/null || echo "[]")

          if [[ "$LOG_ENTRIES" == "[]" || -z "$LOG_ENTRIES" ]]; then
            echo "SIGN_042: No transparency log entries found for signature"
            exit 1
          fi

          # Extract log entry UUIDs
          LOG_UUIDS=$(echo "$LOG_ENTRIES" | jq -r '.[]' 2>/dev/null || echo "")

          if [[ -z "$LOG_UUIDS" ]]; then
            echo "SIGN_043: Could not extract log entry UUIDs"
            exit 1
          fi

          echo "Found transparency log entries:"
          echo "$LOG_UUIDS"

          # Get detailed information for the first log entry
          FIRST_UUID=$(echo "$LOG_UUIDS" | head -1)
          echo "Retrieving details for log entry: $FIRST_UUID"

          LOG_ENTRY_DETAILS=$(rekor-cli get --uuid "$FIRST_UUID" --format json 2>/dev/null || echo "{}")

          if [[ "$LOG_ENTRY_DETAILS" == "{}" ]]; then
            echo "SIGN_044: Could not retrieve log entry details"
            exit 1
          fi

          # Extract log entry metadata
          LOG_INDEX=$(echo "$LOG_ENTRY_DETAILS" | jq -r '.LogIndex // empty')
          LOG_ID=$(echo "$LOG_ENTRY_DETAILS" | jq -r '.LogID // empty')
          INTEGRATED_TIME=$(echo "$LOG_ENTRY_DETAILS" | jq -r '.IntegratedTime // empty')

          echo "Transparency log entry verified:"
          echo "  UUID: $FIRST_UUID"
          echo "  Log Index: $LOG_INDEX"
          echo "  Log ID: $LOG_ID"
          echo "  Integrated Time: $INTEGRATED_TIME"

          # Store log entry information
          echo "log_entry_uuid=$FIRST_UUID" >> $GITHUB_OUTPUT
          echo "log_index=$LOG_INDEX" >> $GITHUB_OUTPUT
          echo "integrated_time=$INTEGRATED_TIME" >> $GITHUB_OUTPUT
          echo "rekor_verified=true" >> $GITHUB_OUTPUT

          echo "PASS: Rekor transparency log integration verified"

          # Clean up temporary files
          rm -f /tmp/pub_key.pem

      - name: Sign SBOM artifacts with keyless signing
        id: sbom-signing
        run: |
          echo "Extending keyless signing to cover SBOM artifacts..."

          # Check if SBOM files exist from vulnerability scanning job
          CYCLONEDX_SBOM="sbom-cyclonedx.json"
          SPDX_SBOM="sbom-spdx.json"

          # Download SBOM artifacts from previous job
          echo "Downloading SBOM artifacts for signing..."

          # Since we're in the same workflow, artifacts from previous jobs need to be shared
          # For now, we'll generate fresh SBOMs for signing demonstration
          CONTAINER_TARGET="${{ steps.prepare-container.outputs.container_target }}"

          # Install Syft for SBOM generation if not available
          if ! command -v syft &> /dev/null; then
            echo "Installing Syft for SBOM generation..."
            curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          fi

          # Generate SBOMs for signing
          echo "Generating SBOMs for signing..."
          syft "$CONTAINER_TARGET" --scope all-layers -o cyclonedx-json="$CYCLONEDX_SBOM"
          syft "$CONTAINER_TARGET" --scope all-layers -o spdx-json="$SPDX_SBOM"

          # Configure SBOM signing metadata
          SIGNING_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          WORKFLOW_REF="${{ github.workflow }}@${{ github.ref }}"
          COMMIT_SHA="${{ github.sha }}"

          # Sign CycloneDX SBOM
          echo "Signing CycloneDX SBOM..."
          CYCLONEDX_ANNOTATIONS=(
            "--annotation=org.opencontainers.image.title=CycloneDX SBOM"
            "--annotation=org.opencontainers.image.description=Software Bill of Materials in CycloneDX format"
            "--annotation=org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}"
            "--annotation=org.opencontainers.image.revision=$COMMIT_SHA"
            "--annotation=org.opencontainers.image.created=$SIGNING_TIME"
            "--annotation=keystone.sbom.format=cyclonedx"
            "--annotation=keystone.sbom.version=1.6"
            "--annotation=keystone.sbom.target=$CONTAINER_TARGET"
            "--annotation=keystone.signature.workflow=$WORKFLOW_REF"
            "--annotation=keystone.signature.type=keyless"
          )

          if cosign sign-blob --yes "${CYCLONEDX_ANNOTATIONS[@]}" --bundle="$CYCLONEDX_SBOM.bundle" "$CYCLONEDX_SBOM"; then
            echo "PASS: CycloneDX SBOM signed successfully"
            echo "cyclonedx_signed=true" >> $GITHUB_OUTPUT
          else
            echo "SIGN_061: CycloneDX SBOM signing failed"
            exit 1
          fi

          # Sign SPDX SBOM
          echo "Signing SPDX SBOM..."
          SPDX_ANNOTATIONS=(
            "--annotation=org.opencontainers.image.title=SPDX SBOM"
            "--annotation=org.opencontainers.image.description=Software Bill of Materials in SPDX format"
            "--annotation=org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}"
            "--annotation=org.opencontainers.image.revision=$COMMIT_SHA"
            "--annotation=org.opencontainers.image.created=$SIGNING_TIME"
            "--annotation=keystone.sbom.format=spdx"
            "--annotation=keystone.sbom.version=2.3"
            "--annotation=keystone.sbom.target=$CONTAINER_TARGET"
            "--annotation=keystone.signature.workflow=$WORKFLOW_REF"
            "--annotation=keystone.signature.type=keyless"
          )

          if cosign sign-blob --yes "${SPDX_ANNOTATIONS[@]}" --bundle="$SPDX_SBOM.bundle" "$SPDX_SBOM"; then
            echo "PASS: SPDX SBOM signed successfully"
            echo "spdx_signed=true" >> $GITHUB_OUTPUT
          else
            echo "SIGN_062: SPDX SBOM signing failed"
            exit 1
          fi

          echo "PASS: Multi-artifact signing workflow completed"
          echo "Signed artifacts:"
          echo "  - Container image: $CONTAINER_TARGET"
          echo "  - CycloneDX SBOM: $CYCLONEDX_SBOM"
          echo "  - SPDX SBOM: $SPDX_SBOM"

      - name: Verify SBOM signatures
        id: verify-sbom-signatures
        run: |
          echo "Verifying SBOM signatures with attestation type validation..."

          CYCLONEDX_SBOM="sbom-cyclonedx.json"
          SPDX_SBOM="sbom-spdx.json"

          # Verify CycloneDX SBOM signature
          echo "Verifying CycloneDX SBOM signature..."
          if cosign verify-blob \
              --certificate-identity="$OIDC_SUBJECT" \
              --certificate-oidc-issuer="$OIDC_ISSUER" \
              --bundle="$CYCLONEDX_SBOM.bundle" \
              "$CYCLONEDX_SBOM"; then
            echo "PASS: CycloneDX SBOM signature verified"
            echo "cyclonedx_verified=true" >> $GITHUB_OUTPUT
          else
            echo "SIGN_063: CycloneDX SBOM signature verification failed"
            exit 1
          fi

          # Verify SPDX SBOM signature
          echo "Verifying SPDX SBOM signature..."
          if cosign verify-blob \
              --certificate-identity="$OIDC_SUBJECT" \
              --certificate-oidc-issuer="$OIDC_ISSUER" \
              --bundle="$SPDX_SBOM.bundle" \
              "$SPDX_SBOM"; then
            echo "PASS: SPDX SBOM signature verified"
            echo "spdx_verified=true" >> $GITHUB_OUTPUT
          else
            echo "SIGN_064: SPDX SBOM signature verification failed"
            exit 1
          fi

          echo "PASS: End-to-end SBOM signing and verification workflow completed"

      - name: Upload signed SBOM artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: signed-sbom-artifacts
          path: |
            sbom-cyclonedx.json
            sbom-cyclonedx.json.bundle
            sbom-spdx.json
            sbom-spdx.json.bundle
          retention-days: 30

      - name: Comprehensive error handling and monitoring
        id: error-handling
        if: always()
        run: |
          echo "Implementing comprehensive error handling with error taxonomy..."

          # Initialize error tracking
          ERROR_COUNT=0
          ERROR_REPORT=""
          SEVERITY_CRITICAL=0
          SEVERITY_HIGH=0
          SEVERITY_MEDIUM=0

          # Check each signing component
          echo "Analyzing signing workflow results..."

          # Check Cosign installation
          if [[ "${{ steps.install-cosign.outcome }}" != "success" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_CRITICAL=$((SEVERITY_CRITICAL + 1))
            ERROR_REPORT+="\nSIGN_011: Cosign CLI installation failed - CRITICAL"
          fi

          # Check OIDC token configuration
          if [[ "${{ steps.test-oidc.outcome }}" != "success" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_CRITICAL=$((SEVERITY_CRITICAL + 1))
            ERROR_REPORT+="\nSIGN_001-006: OIDC token configuration failed - CRITICAL"
          fi

          # Check container signing
          if [[ "${{ steps.keyless-signing.outputs.container_signed }}" != "true" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_HIGH=$((SEVERITY_HIGH + 1))
            ERROR_REPORT+="\nSIGN_031: Container image signing failed - HIGH"
          fi

          # Check signature verification
          if [[ "${{ steps.verify-signature.outputs.signature_verified }}" != "true" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_HIGH=$((SEVERITY_HIGH + 1))
            ERROR_REPORT+="\nSIGN_051: Container signature verification failed - HIGH"
          fi

          # Check Rekor integration
          if [[ "${{ steps.rekor-verification.outputs.rekor_verified }}" != "true" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_HIGH=$((SEVERITY_HIGH + 1))
            ERROR_REPORT+="\nSIGN_041-044: Rekor transparency log integration failed - HIGH"
          fi

          # Check SBOM signing
          if [[ "${{ steps.sbom-signing.outputs.cyclonedx_signed }}" != "true" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_MEDIUM=$((SEVERITY_MEDIUM + 1))
            ERROR_REPORT+="\nSIGN_061: CycloneDX SBOM signing failed - MEDIUM"
          fi

          if [[ "${{ steps.sbom-signing.outputs.spdx_signed }}" != "true" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_MEDIUM=$((SEVERITY_MEDIUM + 1))
            ERROR_REPORT+="\nSIGN_062: SPDX SBOM signing failed - MEDIUM"
          fi

          # Collect diagnostic information
          echo "Collecting diagnostic information..."

          DIAGNOSTIC_INFO="# Keyless Signing Diagnostic Report\n"
          DIAGNOSTIC_INFO+="Generated: $(date -u +'%Y-%m-%dT%H:%M:%SZ')\n"
          DIAGNOSTIC_INFO+="Workflow: ${{ github.workflow }}\n"
          DIAGNOSTIC_INFO+="Run ID: ${{ github.run_id }}\n"
          DIAGNOSTIC_INFO+="Commit: ${{ github.sha }}\n"
          DIAGNOSTIC_INFO+="Actor: ${{ github.actor }}\n"
          DIAGNOSTIC_INFO+="Repository: ${{ github.repository }}\n\n"

          DIAGNOSTIC_INFO+="## Error Summary\n"
          DIAGNOSTIC_INFO+="Total Errors: $ERROR_COUNT\n"
          DIAGNOSTIC_INFO+="Critical: $SEVERITY_CRITICAL\n"
          DIAGNOSTIC_INFO+="High: $SEVERITY_HIGH\n"
          DIAGNOSTIC_INFO+="Medium: $SEVERITY_MEDIUM\n\n"

          if [[ $ERROR_COUNT -gt 0 ]]; then
            DIAGNOSTIC_INFO+="## Error Details\n"
            DIAGNOSTIC_INFO+="$ERROR_REPORT\n\n"
          fi

          DIAGNOSTIC_INFO+="## Component Status\n"
          DIAGNOSTIC_INFO+="- Cosign Installation: ${{ steps.install-cosign.outcome }}\n"
          DIAGNOSTIC_INFO+="- OIDC Configuration: ${{ steps.test-oidc.outcome }}\n"
          DIAGNOSTIC_INFO+="- Container Signing: ${{ steps.keyless-signing.outcome }}\n"
          DIAGNOSTIC_INFO+="- Signature Verification: ${{ steps.verify-signature.outcome }}\n"
          DIAGNOSTIC_INFO+="- Rekor Integration: ${{ steps.rekor-verification.outcome }}\n"
          DIAGNOSTIC_INFO+="- SBOM Signing: ${{ steps.sbom-signing.outcome }}\n"
          DIAGNOSTIC_INFO+="- SBOM Verification: ${{ steps.verify-sbom-signatures.outcome }}\n\n"

          DIAGNOSTIC_INFO+="## Configuration Details\n"
          DIAGNOSTIC_INFO+="- Cosign Version: $(cosign version --json 2>/dev/null | jq -r '.gitVersion' || 'N/A')\n"
          DIAGNOSTIC_INFO+="- OIDC Issuer: $OIDC_ISSUER\n"
          DIAGNOSTIC_INFO+="- OIDC Subject: $OIDC_SUBJECT\n"
          DIAGNOSTIC_INFO+="- Rekor URL: $REKOR_URL\n"

          # Save diagnostic report
          echo -e "$DIAGNOSTIC_INFO" > keyless-signing-diagnostic.md

          # Output results
          echo "error_count=$ERROR_COUNT" >> $GITHUB_OUTPUT
          echo "severity_critical=$SEVERITY_CRITICAL" >> $GITHUB_OUTPUT
          echo "severity_high=$SEVERITY_HIGH" >> $GITHUB_OUTPUT
          echo "severity_medium=$SEVERITY_MEDIUM" >> $GITHUB_OUTPUT

          # Add to GitHub step summary
          {
            echo "# Keyless Signing Workflow Results"
            echo ""
            echo "## Overall Status"
            if [[ $ERROR_COUNT -eq 0 ]]; then
              echo "✅ **SUCCESS**: All keyless signing operations completed successfully"
            elif [[ $SEVERITY_CRITICAL -gt 0 ]]; then
              echo "❌ **FAILED**: Critical errors detected in signing workflow"
            elif [[ $SEVERITY_HIGH -gt 0 ]]; then
              echo "⚠️ **PARTIAL**: High severity issues detected"
            else
              echo "⚠️ **WARNING**: Medium severity issues detected"
            fi
            echo ""
            echo "## Error Summary"
            echo "| Severity | Count |"
            echo "|----------|-------|"
            echo "| Critical | $SEVERITY_CRITICAL |"
            echo "| High | $SEVERITY_HIGH |"
            echo "| Medium | $SEVERITY_MEDIUM |"
            echo "| **Total** | **$ERROR_COUNT** |"
            echo ""
            echo "## Component Results"
            echo "| Component | Status | Result |"
            echo "|-----------|--------|--------|"
            echo "| Cosign Installation | ${{ steps.install-cosign.outcome }} | $([ '${{ steps.install-cosign.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| OIDC Configuration | ${{ steps.test-oidc.outcome }} | $([ '${{ steps.test-oidc.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| Container Signing | ${{ steps.keyless-signing.outcome }} | $([ '${{ steps.keyless-signing.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| Signature Verification | ${{ steps.verify-signature.outcome }} | $([ '${{ steps.verify-signature.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| Rekor Integration | ${{ steps.rekor-verification.outcome }} | $([ '${{ steps.rekor-verification.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| SBOM Signing | ${{ steps.sbom-signing.outcome }} | $([ '${{ steps.sbom-signing.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| SBOM Verification | ${{ steps.verify-sbom-signatures.outcome }} | $([ '${{ steps.verify-sbom-signatures.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"

            if [[ $ERROR_COUNT -gt 0 ]]; then
              echo ""
              echo "## Error Details"
              echo -e "$ERROR_REPORT"
            fi

            echo ""
            echo "## Artifacts"
            echo "- [Diagnostic Report](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (keyless-signing-diagnostic artifact)"
            echo "- [Signed SBOMs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (signed-sbom-artifacts artifact)"

          } >> $GITHUB_STEP_SUMMARY

          # Determine workflow exit status
          if [[ $SEVERITY_CRITICAL -gt 0 ]]; then
            echo "CRITICAL errors detected - failing workflow"
            exit 1
          elif [[ $SEVERITY_HIGH -gt 0 ]]; then
            echo "HIGH severity issues detected - workflow will continue with warnings"
          else
            echo "Keyless signing workflow completed successfully"
          fi

      - name: Upload diagnostic report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: keyless-signing-diagnostic
          path: keyless-signing-diagnostic.md
          retention-days: 30