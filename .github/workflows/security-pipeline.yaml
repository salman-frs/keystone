name: Security Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  GO_VERSION: '1.25'
  NODE_VERSION: '22'

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      go-version: ${{ steps.versions.outputs.go-version }}
      node-version: ${{ steps.versions.outputs.node-version }}
    steps:
      - name: Set versions
        id: versions
        run: |
          echo "go-version=${{ env.GO_VERSION }}" >> $GITHUB_OUTPUT
          echo "node-version=${{ env.NODE_VERSION }}" >> $GITHUB_OUTPUT

  backend-build:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ needs.setup.outputs.go-version }}

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Build Go services
        run: |
          echo "Backend build step - Go services will be built here"
          echo "Current directory structure created for future Go services"

  frontend-build:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ needs.setup.outputs.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          echo "Frontend build step - Node.js dependencies will be installed here"
          echo "Dashboard application structure created for future React development"

      - name: Build frontend
        run: |
          echo "Frontend React dashboard will be built here"

  vulnerability-scanning:
    runs-on: ubuntu-latest
    needs: [backend-build, frontend-build]
    permissions:
      security-events: write
      packages: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build vulnerable demo container
        run: |
          docker build -t vulnerable-demo:latest examples/vulnerable-app/
          echo "Built vulnerable demo container for scanning"

      - name: Run Trivy scanner
        id: trivy-scan
        run: |
          echo "Running Trivy vulnerability scan..."
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v "${{ github.workspace }}":/workspace \
            aquasec/trivy:latest image \
            --format json \
            --output /workspace/trivy-results.json \
            vulnerable-demo:latest
          echo "Trivy scan completed"
        continue-on-error: true

      - name: Run Grype scanner
        id: grype-scan
        run: |
          echo "Running Grype vulnerability scan..."
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
          grype vulnerable-demo:latest \
            -o json \
            --file grype-results.json
          echo "Grype scan completed"
        continue-on-error: true

      - name: Parse vulnerability counts
        id: parse-results
        run: |
          echo "Parsing vulnerability results..."

          # Parse Trivy results
          if [[ -f trivy-results.json ]]; then
            trivy_critical=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' trivy-results.json 2>/dev/null || echo "0")
            trivy_high=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH")] | length' trivy-results.json 2>/dev/null || echo "0")
            trivy_medium=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "MEDIUM")] | length' trivy-results.json 2>/dev/null || echo "0")
            trivy_low=$(jq '[.Results[]?.Vulnerabilities[]? | select(.Severity == "LOW")] | length' trivy-results.json 2>/dev/null || echo "0")
            trivy_total=$((trivy_critical + trivy_high + trivy_medium + trivy_low))
          else
            trivy_critical=0; trivy_high=0; trivy_medium=0; trivy_low=0; trivy_total=0
          fi

          # Parse Grype results
          if [[ -f grype-results.json ]]; then
            grype_critical=$(jq '[.matches[]? | select(.vulnerability.severity == "Critical")] | length' grype-results.json 2>/dev/null || echo "0")
            grype_high=$(jq '[.matches[]? | select(.vulnerability.severity == "High")] | length' grype-results.json 2>/dev/null || echo "0")
            grype_medium=$(jq '[.matches[]? | select(.vulnerability.severity == "Medium")] | length' grype-results.json 2>/dev/null || echo "0")
            grype_low=$(jq '[.matches[]? | select(.vulnerability.severity == "Low")] | length' grype-results.json 2>/dev/null || echo "0")
            grype_total=$((grype_critical + grype_high + grype_medium + grype_low))
          else
            grype_critical=0; grype_high=0; grype_medium=0; grype_low=0; grype_total=0
          fi

          # Output to GitHub Actions summary
          {
            echo "# Security Pipeline Results"
            echo ""
            echo "## Vulnerability Scan Results"
            echo "| Scanner | Critical | High | Medium | Low | Total |"
            echo "|---------|----------|------|--------|-----|-------|"
            echo "| **Trivy** | $trivy_critical | $trivy_high | $trivy_medium | $trivy_low | **$trivy_total** |"
            echo "| **Grype** | $grype_critical | $grype_high | $grype_medium | $grype_low | **$grype_total** |"
            echo ""
            echo "## SBOM Generation Results"
            echo "| Format | Components/Packages | Validation | Status |"
            echo "|---------|----------|------|-------|"
            cyclonedx_validation=$([ "${{ steps.validate-sbom.outputs.validation_errors }}" = "0" ] && echo "PASS" || echo "FAIL")
            spdx_validation=$([ "${{ steps.validate-sbom.outputs.validation_errors }}" = "0" ] && echo "PASS" || echo "FAIL")
            cyclonedx_status=$([ "${{ steps.sbom-cyclonedx.outcome }}" = "success" ] && echo "Generated" || echo "Failed")
            spdx_status=$([ "${{ steps.sbom-spdx.outcome }}" = "success" ] && echo "Generated" || echo "Failed")
            echo "| **CycloneDX** | ${{ steps.parse-sbom.outputs.cyclonedx_components }} components | $cyclonedx_validation | $cyclonedx_status |"
            echo "| **SPDX** | ${{ steps.parse-sbom.outputs.spdx_packages }} packages | $spdx_validation | $spdx_status |"
            echo ""
            echo "## SBOM Metadata"
            echo "- **Target**: vulnerable-demo:latest container"
            echo "- **Scope**: All container layers included"
            echo "- **CycloneDX Component**: ${{ steps.parse-sbom.outputs.cyclonedx_metadata }}"
            echo "- **SPDX Document**: ${{ steps.parse-sbom.outputs.spdx_name }}"
            echo "- **Unique Licenses**: ${{ steps.parse-sbom.outputs.cyclonedx_licenses }}"
            echo "- **SPDX Relationships**: ${{ steps.parse-sbom.outputs.spdx_relationships }}"
            echo ""
            echo "## SBOM Container Registry References"
            if [[ "${{ steps.upload-cyclonedx.outcome }}" == "success" ]]; then
              echo "- **CycloneDX SBOM**: \`${{ steps.upload-cyclonedx.outputs.cyclonedx_registry_ref }}\`"
            else
              echo "- **CycloneDX SBOM**: Upload failed"
            fi
            if [[ "${{ steps.upload-spdx.outcome }}" == "success" ]]; then
              echo "- **SPDX SBOM**: \`${{ steps.upload-spdx.outputs.spdx_registry_ref }}\`"
            else
              echo "- **SPDX SBOM**: Upload failed"
            fi
            echo ""
            echo "## Artifact Downloads"
            echo "- [CycloneDX SBOM](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (sbom-cyclonedx artifact)"
            echo "- [SPDX SBOM](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (sbom-spdx artifact)"
            echo "- [Trivy Results](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (trivy-vulnerability-results artifact)"
            echo "- [Grype Results](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (grype-vulnerability-results artifact)"
            echo ""
            echo "## Scan Details"
            echo "- **OS Packages**: Scanned for known vulnerabilities"
            echo "- **Dependencies**: Go modules and application dependencies analyzed"
            echo "- **Base Image**: Container base image vulnerabilities detected"
          } >> $GITHUB_STEP_SUMMARY

          echo "Vulnerability count parsing completed"

      - name: Upload Trivy results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: trivy-vulnerability-results
          path: trivy-results.json
          retention-days: 30

      - name: Upload Grype results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: grype-vulnerability-results
          path: grype-results.json
          retention-days: 30

      - name: Install Syft SBOM generator
        run: |
          echo "Installing Syft for SBOM generation..."
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          syft version
          echo "Syft installation completed"

      - name: Generate SBOM in CycloneDX format
        id: sbom-cyclonedx
        run: |
          echo "Generating CycloneDX SBOM for vulnerable-demo:latest..."
          syft vulnerable-demo:latest \
            --scope all-layers \
            -o cyclonedx-json=sbom-cyclonedx.json \
            -v
          echo "CycloneDX SBOM generation completed"
        continue-on-error: true

      - name: Generate SBOM in SPDX format
        id: sbom-spdx
        run: |
          echo "Generating SPDX SBOM for vulnerable-demo:latest..."
          syft vulnerable-demo:latest \
            --scope all-layers \
            -o spdx-json=sbom-spdx.json \
            -v
          echo "SPDX SBOM generation completed"
        continue-on-error: true

      - name: Install SBOM validation tools
        run: |
          echo "Installing SBOM validation tools..."
          # Install CycloneDX CLI for validation
          npm install -g @cyclonedx/cyclonedx-cli
          # Install SPDX tools for validation
          pip install spdx-tools
          echo "SBOM validation tools installed"

      - name: Validate SBOM formats
        id: validate-sbom
        run: |
          echo "Validating SBOM format compliance..."
          validation_errors=0
          
          # Validate CycloneDX SBOM
          if [[ -f sbom-cyclonedx.json ]]; then
            echo "Validating CycloneDX SBOM format..."
            if cyclonedx-cli validate --input-file sbom-cyclonedx.json; then
              echo "PASS: CycloneDX SBOM validation passed"
            else
              echo "FAIL: CycloneDX SBOM validation failed"
              validation_errors=$((validation_errors + 1))
            fi
          else
            echo "FAIL: CycloneDX SBOM file not found"
            validation_errors=$((validation_errors + 1))
          fi
          
          # Validate SPDX SBOM
          if [[ -f sbom-spdx.json ]]; then
            echo "Validating SPDX SBOM format..."
            if spdx-tools-convert sbom-spdx.json; then
              echo "PASS: SPDX SBOM validation passed"
            else
              echo "FAIL: SPDX SBOM validation failed"
              validation_errors=$((validation_errors + 1))
            fi
          else
            echo "FAIL: SPDX SBOM file not found"
            validation_errors=$((validation_errors + 1))
          fi
          
          echo "validation_errors=$validation_errors" >> $GITHUB_OUTPUT
          
          if [[ $validation_errors -eq 0 ]]; then
            echo "PASS: All SBOM validations passed"
          else
            echo "FAIL: $validation_errors SBOM validation(s) failed"
          fi
        continue-on-error: true

      - name: Parse SBOM metadata
        id: parse-sbom
        run: |
          echo "Parsing SBOM metadata for summary..."
          
          # Parse CycloneDX SBOM
          if [[ -f sbom-cyclonedx.json ]]; then
            cyclonedx_components=$(jq '.components | length' sbom-cyclonedx.json 2>/dev/null || echo "0")
            cyclonedx_metadata=$(jq -r '.metadata.component.name // "N/A"' sbom-cyclonedx.json 2>/dev/null || echo "N/A")
            cyclonedx_licenses=$(jq '[.components[].licenses[]?.license.name // empty] | unique | length' sbom-cyclonedx.json 2>/dev/null || echo "0")
          else
            cyclonedx_components=0; cyclonedx_metadata="N/A"; cyclonedx_licenses=0
          fi
          
          # Parse SPDX SBOM
          if [[ -f sbom-spdx.json ]]; then
            spdx_packages=$(jq '.packages | length' sbom-spdx.json 2>/dev/null || echo "0")
            spdx_name=$(jq -r '.name // "N/A"' sbom-spdx.json 2>/dev/null || echo "N/A")
            spdx_relationships=$(jq '.relationships | length' sbom-spdx.json 2>/dev/null || echo "0")
          else
            spdx_packages=0; spdx_name="N/A"; spdx_relationships=0
          fi
          
          echo "cyclonedx_components=$cyclonedx_components" >> $GITHUB_OUTPUT
          echo "cyclonedx_metadata=$cyclonedx_metadata" >> $GITHUB_OUTPUT
          echo "cyclonedx_licenses=$cyclonedx_licenses" >> $GITHUB_OUTPUT
          echo "spdx_packages=$spdx_packages" >> $GITHUB_OUTPUT
          echo "spdx_name=$spdx_name" >> $GITHUB_OUTPUT
          echo "spdx_relationships=$spdx_relationships" >> $GITHUB_OUTPUT

      - name: Upload CycloneDX SBOM
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: sbom-cyclonedx
          path: sbom-cyclonedx.json
          retention-days: 30

      - name: Upload SPDX SBOM
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: sbom-spdx
          path: sbom-spdx.json
          retention-days: 30

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install ORAS for OCI artifact uploads
        run: |
          echo "Installing ORAS for OCI artifact management..."
          curl -LO https://github.com/oras-project/oras/releases/latest/download/oras_linux_amd64.tar.gz
          mkdir -p oras-install/
          tar -zxf oras_linux_amd64.tar.gz -C oras-install/
          sudo mv oras-install/oras /usr/local/bin/
          rm -rf oras-install oras_linux_amd64.tar.gz
          oras version
          echo "ORAS installation completed"

      - name: Upload CycloneDX SBOM to Container Registry
        id: upload-cyclonedx
        run: |
          echo "Uploading CycloneDX SBOM to GitHub Container Registry..."
          IMAGE_REF="ghcr.io/${{ github.repository_owner }}/$(echo '${{ github.repository }}' | cut -d'/' -f2)"
          SBOM_REF="${IMAGE_REF}/sbom:cyclonedx-${{ github.sha }}"
          
          if [[ -f sbom-cyclonedx.json ]]; then
            oras push "$SBOM_REF" \
              --annotation "org.opencontainers.image.title=CycloneDX SBOM" \
              --annotation "org.opencontainers.image.description=Software Bill of Materials in CycloneDX format" \
              --annotation "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
              --annotation "org.opencontainers.image.revision=${{ github.sha }}" \
              --annotation "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
              --annotation "sbom.format=cyclonedx" \
              --annotation "sbom.version=1.6" \
              --annotation "target.image=vulnerable-demo:latest" \
              sbom-cyclonedx.json:application/vnd.cyclonedx+json
            echo "cyclonedx_registry_ref=$SBOM_REF" >> $GITHUB_OUTPUT
            echo "CycloneDX SBOM uploaded successfully to $SBOM_REF"
          else
            echo "FAIL: CycloneDX SBOM file not found for upload"
            exit 1
          fi
        continue-on-error: true

      - name: Upload SPDX SBOM to Container Registry
        id: upload-spdx
        run: |
          echo "Uploading SPDX SBOM to GitHub Container Registry..."
          IMAGE_REF="ghcr.io/${{ github.repository_owner }}/$(echo '${{ github.repository }}' | cut -d'/' -f2)"
          SBOM_REF="${IMAGE_REF}/sbom:spdx-${{ github.sha }}"
          
          if [[ -f sbom-spdx.json ]]; then
            oras push "$SBOM_REF" \
              --annotation "org.opencontainers.image.title=SPDX SBOM" \
              --annotation "org.opencontainers.image.description=Software Bill of Materials in SPDX format" \
              --annotation "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
              --annotation "org.opencontainers.image.revision=${{ github.sha }}" \
              --annotation "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
              --annotation "sbom.format=spdx" \
              --annotation "sbom.version=2.3" \
              --annotation "target.image=vulnerable-demo:latest" \
              spdx-sbom.json:application/spdx+json
            echo "spdx_registry_ref=$SBOM_REF" >> $GITHUB_OUTPUT
            echo "SPDX SBOM uploaded successfully to $SBOM_REF"
          else
            echo "FAIL: SPDX SBOM file not found for upload"
            exit 1
          fi
        continue-on-error: true

      - name: Verify SBOM uploads
        run: |
          echo "Verifying SBOM uploads to Container Registry..."
          upload_errors=0
          
          # Check CycloneDX upload
          if [[ "${{ steps.upload-cyclonedx.outcome }}" == "success" ]]; then
            echo "PASS: CycloneDX SBOM uploaded to registry"
            echo "Registry reference: ${{ steps.upload-cyclonedx.outputs.cyclonedx_registry_ref }}"
          else
            echo "FAIL: CycloneDX SBOM upload failed"
            upload_errors=$((upload_errors + 1))
          fi
          
          # Check SPDX upload
          if [[ "${{ steps.upload-spdx.outcome }}" == "success" ]]; then
            echo "PASS: SPDX SBOM uploaded to registry"
            echo "Registry reference: ${{ steps.upload-spdx.outputs.spdx_registry_ref }}"
          else
            echo "FAIL: SPDX SBOM upload failed"
            upload_errors=$((upload_errors + 1))
          fi
          
          if [[ $upload_errors -eq 0 ]]; then
            echo "PASS: All SBOM uploads completed successfully"
          else
            echo "FAIL: $upload_errors SBOM upload(s) failed"
          fi

      - name: Check scanner failures
        run: |
          trivy_exit=${{ steps.trivy-scan.outcome }}
          grype_exit=${{ steps.grype-scan.outcome }}

          if [[ "$trivy_exit" != "success" && "$grype_exit" != "success" ]]; then
            echo "Both scanners failed - workflow will fail"
            exit 1
          elif [[ "$trivy_exit" != "success" ]]; then
            echo " Trivy scanner failed, but Grype succeeded"
          elif [[ "$grype_exit" != "success" ]]; then
            echo " Grype scanner failed, but Trivy succeeded"
          else
            echo " Both scanners completed successfully"
          fi

  keyless-signing:
    runs-on: ubuntu-latest
    needs: [vulnerability-scanning]
    permissions:
      id-token: write
      contents: read
      packages: write
    env:
      COSIGN_EXPERIMENTAL: 1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Cosign CLI
        id: install-cosign
        run: |
          echo "Installing Cosign CLI v2.2.3..."
          COSIGN_VERSION="v2.2.3"
          COSIGN_BINARY="cosign-linux-amd64"
          COSIGN_URL="https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/${COSIGN_BINARY}"
          COSIGN_CHECKSUM_URL="https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign_checksums.txt"

          # Download Cosign binary and checksums
          curl -sSL "$COSIGN_URL" -o cosign
          curl -sSL "$COSIGN_CHECKSUM_URL" -o cosign_checksums.txt

          # Verify checksum for security
          EXPECTED_CHECKSUM=$(grep "$COSIGN_BINARY" cosign_checksums.txt | cut -d' ' -f1)
          ACTUAL_CHECKSUM=$(sha256sum cosign | cut -d' ' -f1)

          if [[ "$EXPECTED_CHECKSUM" != "$ACTUAL_CHECKSUM" ]]; then
            echo "SIGN_011: Cosign checksum verification failed"
            echo "Expected: $EXPECTED_CHECKSUM"
            echo "Actual: $ACTUAL_CHECKSUM"
            exit 1
          fi

          # Install Cosign
          chmod +x cosign
          sudo mv cosign /usr/local/bin/cosign

          # Verify installation
          cosign version
          echo "Cosign CLI v2.2.3 installed successfully with checksum verification"

      - name: Configure and test GitHub OIDC token
        id: test-oidc
        run: |
          echo "Configuring and testing GitHub OIDC token for Sigstore..."

          # Test OIDC token environment variables
          echo "Testing GitHub OIDC token environment..."
          if [[ -z "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ]]; then
            echo "SIGN_001: OIDC token request token not available"
            exit 1
          fi

          if [[ -z "$ACTIONS_ID_TOKEN_REQUEST_URL" ]]; then
            echo "SIGN_002: OIDC token request URL not available"
            exit 1
          fi

          # Configure OIDC claims for Sigstore
          echo "Configuring OIDC claims for identity verification..."

          # Set issuer and audience for Sigstore
          OIDC_ISSUER="https://token.actions.githubusercontent.com"
          OIDC_AUDIENCE="sigstore"

          # Test OIDC token acquisition
          echo "Testing OIDC token acquisition..."
          OIDC_TOKEN=$(curl -sH "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
                           "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=$OIDC_AUDIENCE" | \
                           jq -r '.value' 2>/dev/null)

          if [[ -z "$OIDC_TOKEN" || "$OIDC_TOKEN" == "null" ]]; then
            echo "SIGN_003: OIDC token acquisition failed"
            exit 1
          fi

          # Validate token claims
          echo "Validating OIDC token claims..."
          TOKEN_HEADER=$(echo "$OIDC_TOKEN" | cut -d'.' -f1)
          TOKEN_PAYLOAD=$(echo "$OIDC_TOKEN" | cut -d'.' -f2)

          # Decode and validate payload (add padding if needed)
          PADDED_PAYLOAD=$(echo "$TOKEN_PAYLOAD" | sed 's/$/===/' | fold -w 4 | head -1)
          TOKEN_CLAIMS=$(echo "$PADDED_PAYLOAD" | base64 -d 2>/dev/null | jq . 2>/dev/null || echo "{}")

          # Extract and validate key claims
          ISS=$(echo "$TOKEN_CLAIMS" | jq -r '.iss // empty')
          AUD=$(echo "$TOKEN_CLAIMS" | jq -r '.aud // empty')
          SUB=$(echo "$TOKEN_CLAIMS" | jq -r '.sub // empty')
          ACTOR=$(echo "$TOKEN_CLAIMS" | jq -r '.actor // empty')
          REPOSITORY=$(echo "$TOKEN_CLAIMS" | jq -r '.repository // empty')

          echo "OIDC Token Claims:"
          echo "  Issuer (iss): $ISS"
          echo "  Audience (aud): $AUD"
          echo "  Subject (sub): $SUB"
          echo "  Actor: $ACTOR"
          echo "  Repository: $REPOSITORY"

          # Validate required claims
          if [[ "$ISS" != "$OIDC_ISSUER" ]]; then
            echo "SIGN_004: Invalid OIDC issuer claim"
            exit 1
          fi

          if [[ "$AUD" != "$OIDC_AUDIENCE" ]]; then
            echo "SIGN_005: Invalid OIDC audience claim"
            exit 1
          fi

          if [[ -z "$SUB" ]]; then
            echo "SIGN_006: Missing OIDC subject claim"
            exit 1
          fi

          # Set environment variables for downstream steps
          echo "OIDC_TOKEN_VERIFIED=true" >> $GITHUB_ENV
          echo "OIDC_ISSUER=$OIDC_ISSUER" >> $GITHUB_ENV
          echo "OIDC_AUDIENCE=$OIDC_AUDIENCE" >> $GITHUB_ENV
          echo "OIDC_SUBJECT=$SUB" >> $GITHUB_ENV

          echo "PASS: OIDC token configuration and validation completed"
          echo "Identity verified: $SUB"

      - name: Test Cosign with OIDC integration
        id: test-cosign
        run: |
          echo "Testing Cosign CLI with OIDC integration..."

          # Test Cosign version and help
          echo "Testing Cosign CLI functionality..."
          cosign version

          # Test OIDC integration
          echo "Testing Cosign OIDC integration..."
          echo "COSIGN_EXPERIMENTAL: $COSIGN_EXPERIMENTAL"
          echo "OIDC verified: $OIDC_TOKEN_VERIFIED"
          echo "OIDC issuer: $OIDC_ISSUER"
          echo "OIDC audience: $OIDC_AUDIENCE"
          echo "OIDC subject: $OIDC_SUBJECT"

          # Verify Cosign can access OIDC token
          if [[ "$OIDC_TOKEN_VERIFIED" != "true" ]]; then
            echo "SIGN_007: OIDC token not verified for Cosign"
            exit 1
          fi

          echo "PASS: Cosign CLI ready for keyless signing with OIDC identity"
          echo "Signing identity: $OIDC_SUBJECT"

      - name: Prepare demo container for signing
        id: prepare-container
        run: |
          echo "Preparing vulnerable demo container for signing tests..."

          # Build the demo container for signing
          docker build -t vulnerable-demo:signing-test examples/vulnerable-app/

          # Get container digest for signing
          CONTAINER_DIGEST=$(docker inspect vulnerable-demo:signing-test --format='{{index .RepoDigests 0}}' 2>/dev/null || echo "")

          if [[ -z "$CONTAINER_DIGEST" ]]; then
            # For local images without repo digests, use image ID
            CONTAINER_ID=$(docker inspect vulnerable-demo:signing-test --format='{{.Id}}')
            echo "container_target=vulnerable-demo:signing-test@$CONTAINER_ID" >> $GITHUB_OUTPUT
            echo "Container prepared for signing: vulnerable-demo:signing-test@$CONTAINER_ID"
          else
            echo "container_target=$CONTAINER_DIGEST" >> $GITHUB_OUTPUT
            echo "Container prepared for signing: $CONTAINER_DIGEST"
          fi

      - name: Implement keyless signing for container images
        id: keyless-signing
        run: |
          echo "Implementing keyless signing for container images..."

          # Get container target from previous step
          CONTAINER_TARGET="${{ steps.prepare-container.outputs.container_target }}"

          if [[ -z "$CONTAINER_TARGET" ]]; then
            echo "SIGN_021: Container target not resolved"
            exit 1
          fi

          echo "Signing target: $CONTAINER_TARGET"
          echo "Signing identity: $OIDC_SUBJECT"

          # Configure signing metadata and annotations
          echo "Configuring signing metadata and annotations..."

          SIGNING_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          WORKFLOW_REF="${{ github.workflow }}@${{ github.ref }}"
          COMMIT_SHA="${{ github.sha }}"

          # Create signing annotations
          ANNOTATIONS=(
            "--annotation=org.opencontainers.image.title=Vulnerable Demo Container"
            "--annotation=org.opencontainers.image.description=Demo container for security scanning"
            "--annotation=org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}"
            "--annotation=org.opencontainers.image.revision=$COMMIT_SHA"
            "--annotation=org.opencontainers.image.created=$SIGNING_TIME"
            "--annotation=keystone.signature.workflow=$WORKFLOW_REF"
            "--annotation=keystone.signature.actor=${{ github.actor }}"
            "--annotation=keystone.signature.repository=${{ github.repository }}"
            "--annotation=keystone.signature.type=keyless"
          )

          # Perform keyless signing using GitHub OIDC identity
          echo "Performing keyless signing with Cosign..."

          if cosign sign --yes "${ANNOTATIONS[@]}" "$CONTAINER_TARGET"; then
            echo "PASS: Container image signed successfully"
            echo "Signature created with OIDC identity: $OIDC_SUBJECT"
            echo "Signed at: $SIGNING_TIME"
            echo "Container: $CONTAINER_TARGET"

            # Store signing results
            echo "container_signed=true" >> $GITHUB_OUTPUT
            echo "signing_time=$SIGNING_TIME" >> $GITHUB_OUTPUT
            echo "signed_identity=$OIDC_SUBJECT" >> $GITHUB_OUTPUT
          else
            echo "SIGN_031: Keyless signing process failed"
            exit 1
          fi

      - name: Verify container signature
        id: verify-signature
        run: |
          echo "Verifying container signature immediately after signing..."

          CONTAINER_TARGET="${{ steps.prepare-container.outputs.container_target }}"

          # Verify signature with identity verification
          echo "Verifying signature with identity: $OIDC_SUBJECT"

          if cosign verify \
              --certificate-identity="$OIDC_SUBJECT" \
              --certificate-oidc-issuer="$OIDC_ISSUER" \
              "$CONTAINER_TARGET"; then
            echo "PASS: Container signature verified successfully"
            echo "Signature verified for identity: $OIDC_SUBJECT"
            echo "signature_verified=true" >> $GITHUB_OUTPUT
          else
            echo "SIGN_051: Signature verification failed"
            exit 1
          fi

      - name: Configure Rekor transparency log integration
        id: rekor-integration
        run: |
          echo "Configuring Rekor transparency log integration..."

          # Configure Rekor transparency log endpoint
          REKOR_URL="https://rekor.sigstore.dev"
          echo "Rekor transparency log endpoint: $REKOR_URL"

          # Install Rekor CLI for log operations
          echo "Installing Rekor CLI for log entry operations..."
          REKOR_VERSION="v1.3.6"
          REKOR_BINARY="rekor-cli-linux-amd64"
          REKOR_CLI_URL="https://github.com/sigstore/rekor/releases/download/${REKOR_VERSION}/${REKOR_BINARY}"

          curl -sSL "$REKOR_CLI_URL" -o rekor-cli
          chmod +x rekor-cli
          sudo mv rekor-cli /usr/local/bin/rekor-cli

          # Test Rekor CLI installation
          rekor-cli version
          echo "Rekor CLI installed successfully"

          # Configure Rekor connection settings
          echo "REKOR_URL=$REKOR_URL" >> $GITHUB_ENV
          echo "rekor_endpoint_configured=true" >> $GITHUB_OUTPUT

      - name: Capture and verify Rekor log entries
        id: rekor-verification
        run: |
          echo "Capturing and verifying Rekor transparency log entries..."

          CONTAINER_TARGET="${{ steps.prepare-container.outputs.container_target }}"

          # Search for log entries related to our signature
          echo "Searching for transparency log entries..."

          # Get the public key used for verification
          PUBLIC_KEY_PEM=$(cosign verify \
              --certificate-identity="$OIDC_SUBJECT" \
              --certificate-oidc-issuer="$OIDC_ISSUER" \
              "$CONTAINER_TARGET" 2>/dev/null | \
              jq -r '.[0].optional.Bundle.Payload.body' | \
              base64 -d | jq -r '.spec.signature.publicKey.content' || echo "")

          if [[ -z "$PUBLIC_KEY_PEM" ]]; then
            echo "SIGN_041: Could not extract public key from signature"
            exit 1
          fi

          # Search Rekor for entries by public key
          echo "Searching Rekor for log entries..."

          # Create temporary file for public key
          echo "$PUBLIC_KEY_PEM" > /tmp/pub_key.pem

          # Search for log entries
          LOG_ENTRIES=$(rekor-cli search --public-key /tmp/pub_key.pem --format json 2>/dev/null || echo "[]")

          if [[ "$LOG_ENTRIES" == "[]" || -z "$LOG_ENTRIES" ]]; then
            echo "SIGN_042: No transparency log entries found for signature"
            exit 1
          fi

          # Extract log entry UUIDs
          LOG_UUIDS=$(echo "$LOG_ENTRIES" | jq -r '.[]' 2>/dev/null || echo "")

          if [[ -z "$LOG_UUIDS" ]]; then
            echo "SIGN_043: Could not extract log entry UUIDs"
            exit 1
          fi

          echo "Found transparency log entries:"
          echo "$LOG_UUIDS"

          # Get detailed information for the first log entry
          FIRST_UUID=$(echo "$LOG_UUIDS" | head -1)
          echo "Retrieving details for log entry: $FIRST_UUID"

          LOG_ENTRY_DETAILS=$(rekor-cli get --uuid "$FIRST_UUID" --format json 2>/dev/null || echo "{}")

          if [[ "$LOG_ENTRY_DETAILS" == "{}" ]]; then
            echo "SIGN_044: Could not retrieve log entry details"
            exit 1
          fi

          # Extract log entry metadata
          LOG_INDEX=$(echo "$LOG_ENTRY_DETAILS" | jq -r '.LogIndex // empty')
          LOG_ID=$(echo "$LOG_ENTRY_DETAILS" | jq -r '.LogID // empty')
          INTEGRATED_TIME=$(echo "$LOG_ENTRY_DETAILS" | jq -r '.IntegratedTime // empty')

          echo "Transparency log entry verified:"
          echo "  UUID: $FIRST_UUID"
          echo "  Log Index: $LOG_INDEX"
          echo "  Log ID: $LOG_ID"
          echo "  Integrated Time: $INTEGRATED_TIME"

          # Store log entry information
          echo "log_entry_uuid=$FIRST_UUID" >> $GITHUB_OUTPUT
          echo "log_index=$LOG_INDEX" >> $GITHUB_OUTPUT
          echo "integrated_time=$INTEGRATED_TIME" >> $GITHUB_OUTPUT
          echo "rekor_verified=true" >> $GITHUB_OUTPUT

          echo "PASS: Rekor transparency log integration verified"

          # Clean up temporary files
          rm -f /tmp/pub_key.pem

      - name: Sign SBOM artifacts with keyless signing
        id: sbom-signing
        run: |
          echo "Extending keyless signing to cover SBOM artifacts..."

          # Check if SBOM files exist from vulnerability scanning job
          CYCLONEDX_SBOM="sbom-cyclonedx.json"
          SPDX_SBOM="sbom-spdx.json"

          # Download SBOM artifacts from previous job
          echo "Downloading SBOM artifacts for signing..."

          # Since we're in the same workflow, artifacts from previous jobs need to be shared
          # For now, we'll generate fresh SBOMs for signing demonstration
          CONTAINER_TARGET="${{ steps.prepare-container.outputs.container_target }}"

          # Install Syft for SBOM generation if not available
          if ! command -v syft &> /dev/null; then
            echo "Installing Syft for SBOM generation..."
            curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          fi

          # Generate SBOMs for signing
          echo "Generating SBOMs for signing..."
          syft "$CONTAINER_TARGET" --scope all-layers -o cyclonedx-json="$CYCLONEDX_SBOM"
          syft "$CONTAINER_TARGET" --scope all-layers -o spdx-json="$SPDX_SBOM"

          # Configure SBOM signing metadata
          SIGNING_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          WORKFLOW_REF="${{ github.workflow }}@${{ github.ref }}"
          COMMIT_SHA="${{ github.sha }}"

          # Sign CycloneDX SBOM
          echo "Signing CycloneDX SBOM..."
          CYCLONEDX_ANNOTATIONS=(
            "--annotation=org.opencontainers.image.title=CycloneDX SBOM"
            "--annotation=org.opencontainers.image.description=Software Bill of Materials in CycloneDX format"
            "--annotation=org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}"
            "--annotation=org.opencontainers.image.revision=$COMMIT_SHA"
            "--annotation=org.opencontainers.image.created=$SIGNING_TIME"
            "--annotation=keystone.sbom.format=cyclonedx"
            "--annotation=keystone.sbom.version=1.6"
            "--annotation=keystone.sbom.target=$CONTAINER_TARGET"
            "--annotation=keystone.signature.workflow=$WORKFLOW_REF"
            "--annotation=keystone.signature.type=keyless"
          )

          if cosign sign-blob --yes "${CYCLONEDX_ANNOTATIONS[@]}" --bundle="$CYCLONEDX_SBOM.bundle" "$CYCLONEDX_SBOM"; then
            echo "PASS: CycloneDX SBOM signed successfully"
            echo "cyclonedx_signed=true" >> $GITHUB_OUTPUT
          else
            echo "SIGN_061: CycloneDX SBOM signing failed"
            exit 1
          fi

          # Sign SPDX SBOM
          echo "Signing SPDX SBOM..."
          SPDX_ANNOTATIONS=(
            "--annotation=org.opencontainers.image.title=SPDX SBOM"
            "--annotation=org.opencontainers.image.description=Software Bill of Materials in SPDX format"
            "--annotation=org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}"
            "--annotation=org.opencontainers.image.revision=$COMMIT_SHA"
            "--annotation=org.opencontainers.image.created=$SIGNING_TIME"
            "--annotation=keystone.sbom.format=spdx"
            "--annotation=keystone.sbom.version=2.3"
            "--annotation=keystone.sbom.target=$CONTAINER_TARGET"
            "--annotation=keystone.signature.workflow=$WORKFLOW_REF"
            "--annotation=keystone.signature.type=keyless"
          )

          if cosign sign-blob --yes "${SPDX_ANNOTATIONS[@]}" --bundle="$SPDX_SBOM.bundle" "$SPDX_SBOM"; then
            echo "PASS: SPDX SBOM signed successfully"
            echo "spdx_signed=true" >> $GITHUB_OUTPUT
          else
            echo "SIGN_062: SPDX SBOM signing failed"
            exit 1
          fi

          echo "PASS: Multi-artifact signing workflow completed"
          echo "Signed artifacts:"
          echo "  - Container image: $CONTAINER_TARGET"
          echo "  - CycloneDX SBOM: $CYCLONEDX_SBOM"
          echo "  - SPDX SBOM: $SPDX_SBOM"

      - name: Verify SBOM signatures
        id: verify-sbom-signatures
        run: |
          echo "Verifying SBOM signatures with attestation type validation..."

          CYCLONEDX_SBOM="sbom-cyclonedx.json"
          SPDX_SBOM="sbom-spdx.json"

          # Verify CycloneDX SBOM signature
          echo "Verifying CycloneDX SBOM signature..."
          if cosign verify-blob \
              --certificate-identity="$OIDC_SUBJECT" \
              --certificate-oidc-issuer="$OIDC_ISSUER" \
              --bundle="$CYCLONEDX_SBOM.bundle" \
              "$CYCLONEDX_SBOM"; then
            echo "PASS: CycloneDX SBOM signature verified"
            echo "cyclonedx_verified=true" >> $GITHUB_OUTPUT
          else
            echo "SIGN_063: CycloneDX SBOM signature verification failed"
            exit 1
          fi

          # Verify SPDX SBOM signature
          echo "Verifying SPDX SBOM signature..."
          if cosign verify-blob \
              --certificate-identity="$OIDC_SUBJECT" \
              --certificate-oidc-issuer="$OIDC_ISSUER" \
              --bundle="$SPDX_SBOM.bundle" \
              "$SPDX_SBOM"; then
            echo "PASS: SPDX SBOM signature verified"
            echo "spdx_verified=true" >> $GITHUB_OUTPUT
          else
            echo "SIGN_064: SPDX SBOM signature verification failed"
            exit 1
          fi

          echo "PASS: End-to-end SBOM signing and verification workflow completed"

      - name: Upload signed SBOM artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: signed-sbom-artifacts
          path: |
            sbom-cyclonedx.json
            sbom-cyclonedx.json.bundle
            sbom-spdx.json
            sbom-spdx.json.bundle
          retention-days: 30

      - name: Comprehensive error handling and monitoring
        id: error-handling
        if: always()
        run: |
          echo "Implementing comprehensive error handling with error taxonomy..."

          # Initialize error tracking
          ERROR_COUNT=0
          ERROR_REPORT=""
          SEVERITY_CRITICAL=0
          SEVERITY_HIGH=0
          SEVERITY_MEDIUM=0

          # Check each signing component
          echo "Analyzing signing workflow results..."

          # Check Cosign installation
          if [[ "${{ steps.install-cosign.outcome }}" != "success" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_CRITICAL=$((SEVERITY_CRITICAL + 1))
            ERROR_REPORT+="\nSIGN_011: Cosign CLI installation failed - CRITICAL"
          fi

          # Check OIDC token configuration
          if [[ "${{ steps.test-oidc.outcome }}" != "success" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_CRITICAL=$((SEVERITY_CRITICAL + 1))
            ERROR_REPORT+="\nSIGN_001-006: OIDC token configuration failed - CRITICAL"
          fi

          # Check container signing
          if [[ "${{ steps.keyless-signing.outputs.container_signed }}" != "true" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_HIGH=$((SEVERITY_HIGH + 1))
            ERROR_REPORT+="\nSIGN_031: Container image signing failed - HIGH"
          fi

          # Check signature verification
          if [[ "${{ steps.verify-signature.outputs.signature_verified }}" != "true" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_HIGH=$((SEVERITY_HIGH + 1))
            ERROR_REPORT+="\nSIGN_051: Container signature verification failed - HIGH"
          fi

          # Check Rekor integration
          if [[ "${{ steps.rekor-verification.outputs.rekor_verified }}" != "true" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_HIGH=$((SEVERITY_HIGH + 1))
            ERROR_REPORT+="\nSIGN_041-044: Rekor transparency log integration failed - HIGH"
          fi

          # Check SBOM signing
          if [[ "${{ steps.sbom-signing.outputs.cyclonedx_signed }}" != "true" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_MEDIUM=$((SEVERITY_MEDIUM + 1))
            ERROR_REPORT+="\nSIGN_061: CycloneDX SBOM signing failed - MEDIUM"
          fi

          if [[ "${{ steps.sbom-signing.outputs.spdx_signed }}" != "true" ]]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
            SEVERITY_MEDIUM=$((SEVERITY_MEDIUM + 1))
            ERROR_REPORT+="\nSIGN_062: SPDX SBOM signing failed - MEDIUM"
          fi

          # Collect diagnostic information
          echo "Collecting diagnostic information..."

          DIAGNOSTIC_INFO="# Keyless Signing Diagnostic Report\n"
          DIAGNOSTIC_INFO+="Generated: $(date -u +'%Y-%m-%dT%H:%M:%SZ')\n"
          DIAGNOSTIC_INFO+="Workflow: ${{ github.workflow }}\n"
          DIAGNOSTIC_INFO+="Run ID: ${{ github.run_id }}\n"
          DIAGNOSTIC_INFO+="Commit: ${{ github.sha }}\n"
          DIAGNOSTIC_INFO+="Actor: ${{ github.actor }}\n"
          DIAGNOSTIC_INFO+="Repository: ${{ github.repository }}\n\n"

          DIAGNOSTIC_INFO+="## Error Summary\n"
          DIAGNOSTIC_INFO+="Total Errors: $ERROR_COUNT\n"
          DIAGNOSTIC_INFO+="Critical: $SEVERITY_CRITICAL\n"
          DIAGNOSTIC_INFO+="High: $SEVERITY_HIGH\n"
          DIAGNOSTIC_INFO+="Medium: $SEVERITY_MEDIUM\n\n"

          if [[ $ERROR_COUNT -gt 0 ]]; then
            DIAGNOSTIC_INFO+="## Error Details\n"
            DIAGNOSTIC_INFO+="$ERROR_REPORT\n\n"
          fi

          DIAGNOSTIC_INFO+="## Component Status\n"
          DIAGNOSTIC_INFO+="- Cosign Installation: ${{ steps.install-cosign.outcome }}\n"
          DIAGNOSTIC_INFO+="- OIDC Configuration: ${{ steps.test-oidc.outcome }}\n"
          DIAGNOSTIC_INFO+="- Container Signing: ${{ steps.keyless-signing.outcome }}\n"
          DIAGNOSTIC_INFO+="- Signature Verification: ${{ steps.verify-signature.outcome }}\n"
          DIAGNOSTIC_INFO+="- Rekor Integration: ${{ steps.rekor-verification.outcome }}\n"
          DIAGNOSTIC_INFO+="- SBOM Signing: ${{ steps.sbom-signing.outcome }}\n"
          DIAGNOSTIC_INFO+="- SBOM Verification: ${{ steps.verify-sbom-signatures.outcome }}\n\n"

          DIAGNOSTIC_INFO+="## Configuration Details\n"
          DIAGNOSTIC_INFO+="- Cosign Version: $(cosign version --json 2>/dev/null | jq -r '.gitVersion' || 'N/A')\n"
          DIAGNOSTIC_INFO+="- OIDC Issuer: $OIDC_ISSUER\n"
          DIAGNOSTIC_INFO+="- OIDC Subject: $OIDC_SUBJECT\n"
          DIAGNOSTIC_INFO+="- Rekor URL: $REKOR_URL\n"

          # Save diagnostic report
          echo -e "$DIAGNOSTIC_INFO" > keyless-signing-diagnostic.md

          # Output results
          echo "error_count=$ERROR_COUNT" >> $GITHUB_OUTPUT
          echo "severity_critical=$SEVERITY_CRITICAL" >> $GITHUB_OUTPUT
          echo "severity_high=$SEVERITY_HIGH" >> $GITHUB_OUTPUT
          echo "severity_medium=$SEVERITY_MEDIUM" >> $GITHUB_OUTPUT

          # Add to GitHub step summary
          {
            echo "# Keyless Signing Workflow Results"
            echo ""
            echo "## Overall Status"
            if [[ $ERROR_COUNT -eq 0 ]]; then
              echo "✅ **SUCCESS**: All keyless signing operations completed successfully"
            elif [[ $SEVERITY_CRITICAL -gt 0 ]]; then
              echo "❌ **FAILED**: Critical errors detected in signing workflow"
            elif [[ $SEVERITY_HIGH -gt 0 ]]; then
              echo "⚠️ **PARTIAL**: High severity issues detected"
            else
              echo "⚠️ **WARNING**: Medium severity issues detected"
            fi
            echo ""
            echo "## Error Summary"
            echo "| Severity | Count |"
            echo "|----------|-------|"
            echo "| Critical | $SEVERITY_CRITICAL |"
            echo "| High | $SEVERITY_HIGH |"
            echo "| Medium | $SEVERITY_MEDIUM |"
            echo "| **Total** | **$ERROR_COUNT** |"
            echo ""
            echo "## Component Results"
            echo "| Component | Status | Result |"
            echo "|-----------|--------|--------|"
            echo "| Cosign Installation | ${{ steps.install-cosign.outcome }} | $([ '${{ steps.install-cosign.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| OIDC Configuration | ${{ steps.test-oidc.outcome }} | $([ '${{ steps.test-oidc.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| Container Signing | ${{ steps.keyless-signing.outcome }} | $([ '${{ steps.keyless-signing.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| Signature Verification | ${{ steps.verify-signature.outcome }} | $([ '${{ steps.verify-signature.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| Rekor Integration | ${{ steps.rekor-verification.outcome }} | $([ '${{ steps.rekor-verification.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| SBOM Signing | ${{ steps.sbom-signing.outcome }} | $([ '${{ steps.sbom-signing.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"
            echo "| SBOM Verification | ${{ steps.verify-sbom-signatures.outcome }} | $([ '${{ steps.verify-sbom-signatures.outcome }}' = 'success' ] && echo '✅' || echo '❌') |"

            if [[ $ERROR_COUNT -gt 0 ]]; then
              echo ""
              echo "## Error Details"
              echo -e "$ERROR_REPORT"
            fi

            echo ""
            echo "## Artifacts"
            echo "- [Diagnostic Report](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (keyless-signing-diagnostic artifact)"
            echo "- [Signed SBOMs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (signed-sbom-artifacts artifact)"

          } >> $GITHUB_STEP_SUMMARY

          # Determine workflow exit status
          if [[ $SEVERITY_CRITICAL -gt 0 ]]; then
            echo "CRITICAL errors detected - failing workflow"
            exit 1
          elif [[ $SEVERITY_HIGH -gt 0 ]]; then
            echo "HIGH severity issues detected - workflow will continue with warnings"
          else
            echo "Keyless signing workflow completed successfully"
          fi

      - name: Upload diagnostic report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: keyless-signing-diagnostic
          path: keyless-signing-diagnostic.md
          retention-days: 30

  slsa-provenance:
    runs-on: ubuntu-latest
    needs: [keyless-signing, vulnerability-scanning]
    permissions:
      id-token: write
      contents: read
      packages: write
    env:
      COSIGN_EXPERIMENTAL: 1
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install SLSA provenance tools
        id: install-slsa-tools
        run: |
          echo "Installing SLSA provenance generation tools..."

          # Install Cosign CLI (reuse from keyless signing)
          COSIGN_VERSION="v2.2.3"
          COSIGN_BINARY="cosign-linux-amd64"
          COSIGN_URL="https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/${COSIGN_BINARY}"

          curl -sSL "$COSIGN_URL" -o cosign
          chmod +x cosign
          sudo mv cosign /usr/local/bin/cosign

          # Install SLSA verifier for validation
          SLSA_VERIFIER_VERSION="v2.4.1"
          SLSA_VERIFIER_URL="https://github.com/slsa-framework/slsa-verifier/releases/download/${SLSA_VERIFIER_VERSION}/slsa-verifier-linux-amd64"

          curl -sSL "$SLSA_VERIFIER_URL" -o slsa-verifier
          chmod +x slsa-verifier
          sudo mv slsa-verifier /usr/local/bin/slsa-verifier

          # Install ORAS for OCI operations
          curl -LO https://github.com/oras-project/oras/releases/latest/download/oras_linux_amd64.tar.gz
          mkdir -p oras-install/
          tar -zxf oras_linux_amd64.tar.gz -C oras-install/
          sudo mv oras-install/oras /usr/local/bin/
          rm -rf oras-install oras_linux_amd64.tar.gz

          # Verify installations
          cosign version
          slsa-verifier version
          oras version

          echo "SLSA tools installation completed"

      - name: Configure GitHub OIDC for SLSA attestation
        id: configure-oidc
        run: |
          echo "Configuring GitHub OIDC for SLSA attestation generation..."

          # Test OIDC token environment variables
          if [[ -z "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ]]; then
            echo "ATTEST_011: OIDC token request token not available"
            exit 1
          fi

          if [[ -z "$ACTIONS_ID_TOKEN_REQUEST_URL" ]]; then
            echo "ATTEST_012: OIDC token request URL not available"
            exit 1
          fi

          # Configure OIDC for Sigstore attestation
          OIDC_ISSUER="https://token.actions.githubusercontent.com"
          OIDC_AUDIENCE="sigstore"

          # Get OIDC token for attestation
          OIDC_TOKEN=$(curl -sH "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
                           "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=$OIDC_AUDIENCE" | \
                           jq -r '.value' 2>/dev/null)

          if [[ -z "$OIDC_TOKEN" || "$OIDC_TOKEN" == "null" ]]; then
            echo "ATTEST_013: OIDC token acquisition for attestation failed"
            exit 1
          fi

          # Extract and validate token claims
          TOKEN_PAYLOAD=$(echo "$OIDC_TOKEN" | cut -d'.' -f2)
          PADDED_PAYLOAD=$(echo "$TOKEN_PAYLOAD" | sed 's/$/===/' | fold -w 4 | head -1)
          TOKEN_CLAIMS=$(echo "$PADDED_PAYLOAD" | base64 -d 2>/dev/null | jq . 2>/dev/null || echo "{}")

          SUB=$(echo "$TOKEN_CLAIMS" | jq -r '.sub // empty')
          ACTOR=$(echo "$TOKEN_CLAIMS" | jq -r '.actor // empty')
          REPOSITORY=$(echo "$TOKEN_CLAIMS" | jq -r '.repository // empty')

          # Set environment variables for attestation
          echo "OIDC_ISSUER=$OIDC_ISSUER" >> $GITHUB_ENV
          echo "OIDC_AUDIENCE=$OIDC_AUDIENCE" >> $GITHUB_ENV
          echo "OIDC_SUBJECT=$SUB" >> $GITHUB_ENV
          echo "OIDC_ACTOR=$ACTOR" >> $GITHUB_ENV
          echo "OIDC_REPOSITORY=$REPOSITORY" >> $GITHUB_ENV

          echo "OIDC configuration completed for SLSA attestation"
          echo "Attestation identity: $SUB"

      - name: Collect comprehensive build environment metadata
        id: build-metadata
        run: |
          echo "Collecting comprehensive build environment metadata..."

          BUILD_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')

          # GitHub Actions runner environment
          RUNNER_OS="${{ runner.os }}"
          RUNNER_ARCH="${{ runner.arch }}"
          RUNNER_NAME="${{ runner.name }}"
          RUNNER_TEMP="${{ runner.temp }}"

          # Workflow execution context
          WORKFLOW_NAME="${{ github.workflow }}"
          WORKFLOW_REF="${{ github.workflow_ref }}"
          RUN_ID="${{ github.run_id }}"
          RUN_NUMBER="${{ github.run_number }}"
          RUN_ATTEMPT="${{ github.run_attempt }}"
          JOB_ID="${{ github.job }}"

          # Source code context
          COMMIT_SHA="${{ github.sha }}"
          COMMIT_REF="${{ github.ref }}"
          COMMIT_REF_NAME="${{ github.ref_name }}"
          COMMIT_REF_TYPE="${{ github.ref_type }}"
          REPOSITORY="${{ github.repository }}"
          REPOSITORY_OWNER="${{ github.repository_owner }}"
          ACTOR="${{ github.actor }}"

          # Build tool versions
          GO_VERSION=$(go version 2>/dev/null | awk '{print $3}' || echo "not-installed")
          NODE_VERSION=$(node --version 2>/dev/null || echo "not-installed")
          DOCKER_VERSION=$(docker --version 2>/dev/null | awk '{print $3}' | sed 's/,//' || echo "not-installed")

          # System information
          SYSTEM_INFO=$(uname -a)
          DISK_USAGE=$(df -h / | tail -1 | awk '{print $5}')
          MEMORY_INFO=$(free -h | head -2 | tail -1 | awk '{print $2}')

          # Create build metadata JSON
          BUILD_METADATA=$(cat <<EOF
          {
            "buildTime": "$BUILD_TIME",
            "runner": {
              "os": "$RUNNER_OS",
              "arch": "$RUNNER_ARCH",
              "name": "$RUNNER_NAME",
              "temp": "$RUNNER_TEMP"
            },
            "workflow": {
              "name": "$WORKFLOW_NAME",
              "ref": "$WORKFLOW_REF",
              "runId": "$RUN_ID",
              "runNumber": "$RUN_NUMBER",
              "runAttempt": "$RUN_ATTEMPT",
              "jobId": "$JOB_ID"
            },
            "source": {
              "commitSha": "$COMMIT_SHA",
              "commitRef": "$COMMIT_REF",
              "commitRefName": "$COMMIT_REF_NAME",
              "commitRefType": "$COMMIT_REF_TYPE",
              "repository": "$REPOSITORY",
              "repositoryOwner": "$REPOSITORY_OWNER",
              "actor": "$ACTOR"
            },
            "buildTools": {
              "go": "$GO_VERSION",
              "node": "$NODE_VERSION",
              "docker": "$DOCKER_VERSION"
            },
            "system": {
              "info": "$SYSTEM_INFO",
              "diskUsage": "$DISK_USAGE",
              "memory": "$MEMORY_INFO"
            }
          }
          EOF
          )

          # Save build metadata
          echo "$BUILD_METADATA" | jq . > build-metadata.json

          # Output key values
          echo "build_time=$BUILD_TIME" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "workflow_ref=$WORKFLOW_REF" >> $GITHUB_OUTPUT
          echo "runner_info=$RUNNER_OS-$RUNNER_ARCH" >> $GITHUB_OUTPUT

          echo "Build environment metadata collection completed"

      - name: Generate SLSA v1.0 provenance statement
        id: generate-provenance
        run: |
          echo "Generating SLSA v1.0 provenance statement..."

          # Prepare container target for provenance
          CONTAINER_IMAGE="vulnerable-demo:latest"

          # Build the demo container to get artifact digest
          docker build -t "$CONTAINER_IMAGE" examples/vulnerable-app/
          CONTAINER_DIGEST=$(docker inspect "$CONTAINER_IMAGE" --format='{{.Id}}')

          # Generate artifact digest
          ARTIFACT_DIGEST="sha256:${CONTAINER_DIGEST#sha256:}"

          BUILD_TIME="${{ steps.build-metadata.outputs.build_time }}"
          COMMIT_SHA="${{ steps.build-metadata.outputs.commit_sha }}"
          WORKFLOW_REF="${{ steps.build-metadata.outputs.workflow_ref }}"

          # Create SLSA v1.0 provenance statement
          SLSA_PROVENANCE=$(cat <<EOF
          {
            "_type": "https://in-toto.io/Statement/v1",
            "subject": [
              {
                "name": "$CONTAINER_IMAGE",
                "digest": {
                  "sha256": "${CONTAINER_DIGEST#sha256:}"
                }
              }
            ],
            "predicateType": "https://slsa.dev/provenance/v1",
            "predicate": {
              "buildDefinition": {
                "buildType": "https://github.com/Attestations/GitHubActionsWorkflow@v1",
                "externalParameters": {
                  "workflow": {
                    "ref": "$WORKFLOW_REF",
                    "repository": "${{ github.repository }}",
                    "path": ".github/workflows/security-pipeline.yaml"
                  }
                },
                "internalParameters": {
                  "github": {
                    "event_name": "${{ github.event_name }}",
                    "repository_id": "${{ github.repository_id }}",
                    "repository_owner_id": "${{ github.repository_owner_id }}"
                  }
                },
                "resolvedDependencies": [
                  {
                    "uri": "git+${{ github.server_url }}/${{ github.repository }}@$COMMIT_SHA",
                    "digest": {
                      "sha1": "$COMMIT_SHA"
                    }
                  }
                ]
              },
              "runDetails": {
                "builder": {
                  "id": "https://github.com/actions/runner"
                },
                "metadata": {
                  "invocationId": "${{ github.run_id }}",
                  "startedOn": "$BUILD_TIME",
                  "finishedOn": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')"
                },
                "byproducts": [
                  {
                    "name": "build-metadata.json",
                    "digest": {
                      "sha256": "$(sha256sum build-metadata.json | cut -d' ' -f1)"
                    }
                  }
                ]
              }
            }
          }
          EOF
          )

          # Save SLSA provenance
          echo "$SLSA_PROVENANCE" | jq . > slsa-provenance.json

          # Output key values
          echo "artifact_digest=$ARTIFACT_DIGEST" >> $GITHUB_OUTPUT
          echo "container_target=$CONTAINER_IMAGE" >> $GITHUB_OUTPUT

          echo "SLSA v1.0 provenance statement generated"
          echo "Target artifact: $CONTAINER_IMAGE"
          echo "Artifact digest: $ARTIFACT_DIGEST"

      - name: Generate multi-predicate attestations
        id: multi-predicate
        run: |
          echo "Generating multi-predicate attestations (SLSA, SBOM, Vulnerability)..."

          CONTAINER_TARGET="${{ steps.generate-provenance.outputs.container_target }}"
          BUILD_TIME="${{ steps.build-metadata.outputs.build_time }}"

          # Install Syft for SBOM generation
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

          # Generate SBOM attestation predicate (CycloneDX)
          echo "Generating SBOM attestation predicate..."
          syft "$CONTAINER_TARGET" --scope all-layers -o cyclonedx-json=temp-sbom.json

          SBOM_ATTESTATION=$(cat <<EOF
          {
            "_type": "https://in-toto.io/Statement/v1",
            "subject": [
              {
                "name": "$CONTAINER_TARGET",
                "digest": {
                  "sha256": "${{ steps.generate-provenance.outputs.artifact_digest }}"
                }
              }
            ],
            "predicateType": "https://spdx.dev/Document",
            "predicate": $(cat temp-sbom.json)
          }
          EOF
          )

          echo "$SBOM_ATTESTATION" | jq . > sbom-attestation.json

          # Generate vulnerability scan attestation predicate
          echo "Generating vulnerability scan attestation predicate..."

          # Run Trivy scan for attestation
          docker run --rm \
            -v "${{ github.workspace }}":/workspace \
            aquasec/trivy:latest image \
            --format json \
            --output /workspace/vuln-scan.json \
            "$CONTAINER_TARGET" || true

          VULN_ATTESTATION=$(cat <<EOF
          {
            "_type": "https://in-toto.io/Statement/v1",
            "subject": [
              {
                "name": "$CONTAINER_TARGET",
                "digest": {
                  "sha256": "${{ steps.generate-provenance.outputs.artifact_digest }}"
                }
              }
            ],
            "predicateType": "https://cosign.sigstore.dev/attestation/vuln/v1",
            "predicate": {
              "invocation": {
                "uri": "https://github.com/aquasecurity/trivy",
                "producer_id": "trivy-scanner"
              },
              "scanner": {
                "vendor": "Aqua Security",
                "name": "Trivy",
                "version": "latest"
              },
              "result": $(cat vuln-scan.json 2>/dev/null || echo "{}")
            }
          }
          EOF
          )

          echo "$VULN_ATTESTATION" | jq . > vulnerability-attestation.json

          # Clean up temporary files
          rm -f temp-sbom.json

          echo "Multi-predicate attestations generated successfully"
          echo "Generated attestations:"
          echo "  - SLSA provenance: slsa-provenance.json"
          echo "  - SBOM attestation: sbom-attestation.json"
          echo "  - Vulnerability attestation: vulnerability-attestation.json"

      - name: Sign attestations with keyless approach
        id: sign-attestations
        run: |
          echo "Signing attestations using keyless approach..."

          SIGNING_TIME=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          COMMIT_SHA="${{ github.sha }}"
          WORKFLOW_REF="${{ github.workflow }}@${{ github.ref }}"

          # Sign SLSA provenance attestation
          echo "Signing SLSA provenance attestation..."
          SLSA_ANNOTATIONS=(
            "--annotation=org.opencontainers.image.title=SLSA Provenance Attestation"
            "--annotation=org.opencontainers.image.description=SLSA v1.0 provenance for container build"
            "--annotation=org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}"
            "--annotation=org.opencontainers.image.revision=$COMMIT_SHA"
            "--annotation=org.opencontainers.image.created=$SIGNING_TIME"
            "--annotation=keystone.attestation.type=slsa-provenance"
            "--annotation=keystone.attestation.version=v1.0"
            "--annotation=keystone.signature.workflow=$WORKFLOW_REF"
            "--annotation=keystone.signature.type=keyless"
          )

          if cosign sign-blob --yes "${SLSA_ANNOTATIONS[@]}" --bundle="slsa-provenance.json.bundle" slsa-provenance.json; then
            echo "PASS: SLSA provenance attestation signed successfully"
            echo "slsa_signed=true" >> $GITHUB_OUTPUT
          else
            echo "ATTEST_021: SLSA provenance attestation signing failed"
            exit 1
          fi

          # Sign SBOM attestation
          echo "Signing SBOM attestation..."
          SBOM_ANNOTATIONS=(
            "--annotation=org.opencontainers.image.title=SBOM Attestation"
            "--annotation=org.opencontainers.image.description=Software Bill of Materials attestation"
            "--annotation=org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}"
            "--annotation=org.opencontainers.image.revision=$COMMIT_SHA"
            "--annotation=org.opencontainers.image.created=$SIGNING_TIME"
            "--annotation=keystone.attestation.type=sbom"
            "--annotation=keystone.attestation.format=cyclonedx"
            "--annotation=keystone.signature.workflow=$WORKFLOW_REF"
            "--annotation=keystone.signature.type=keyless"
          )

          if cosign sign-blob --yes "${SBOM_ANNOTATIONS[@]}" --bundle="sbom-attestation.json.bundle" sbom-attestation.json; then
            echo "PASS: SBOM attestation signed successfully"
            echo "sbom_signed=true" >> $GITHUB_OUTPUT
          else
            echo "ATTEST_022: SBOM attestation signing failed"
            exit 1
          fi

          # Sign vulnerability attestation
          echo "Signing vulnerability attestation..."
          VULN_ANNOTATIONS=(
            "--annotation=org.opencontainers.image.title=Vulnerability Scan Attestation"
            "--annotation=org.opencontainers.image.description=Vulnerability scan results attestation"
            "--annotation=org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}"
            "--annotation=org.opencontainers.image.revision=$COMMIT_SHA"
            "--annotation=org.opencontainers.image.created=$SIGNING_TIME"
            "--annotation=keystone.attestation.type=vulnerability-scan"
            "--annotation=keystone.attestation.scanner=trivy"
            "--annotation=keystone.signature.workflow=$WORKFLOW_REF"
            "--annotation=keystone.signature.type=keyless"
          )

          if cosign sign-blob --yes "${VULN_ANNOTATIONS[@]}" --bundle="vulnerability-attestation.json.bundle" vulnerability-attestation.json; then
            echo "PASS: Vulnerability attestation signed successfully"
            echo "vuln_signed=true" >> $GITHUB_OUTPUT
          else
            echo "ATTEST_023: Vulnerability attestation signing failed"
            exit 1
          fi

          echo "All attestations signed successfully with keyless approach"

      - name: Store attestations in OCI registry
        id: store-attestations
        run: |
          echo "Storing signed attestations in GitHub Container Registry..."

          # Login to GitHub Container Registry
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

          IMAGE_REF="ghcr.io/${{ github.repository_owner }}/$(echo '${{ github.repository }}' | cut -d'/' -f2)"
          COMMIT_SHA="${{ github.sha }}"

          # Upload SLSA provenance attestation
          SLSA_REF="${IMAGE_REF}/attestations:slsa-provenance-$COMMIT_SHA"
          echo "Uploading SLSA provenance attestation..."

          if oras push "$SLSA_REF" \
            --annotation "org.opencontainers.image.title=SLSA Provenance Attestation" \
            --annotation "org.opencontainers.image.description=SLSA v1.0 provenance attestation" \
            --annotation "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
            --annotation "org.opencontainers.image.revision=$COMMIT_SHA" \
            --annotation "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --annotation "keystone.attestation.type=slsa-provenance" \
            --annotation "keystone.attestation.version=v1.0" \
            --annotation "keystone.attestation.target=${{ steps.generate-provenance.outputs.container_target }}" \
            slsa-provenance.json:application/vnd.in-toto+json \
            slsa-provenance.json.bundle:application/vnd.dev.sigstore.bundle+json+v0.2; then
            echo "slsa_registry_ref=$SLSA_REF" >> $GITHUB_OUTPUT
            echo "PASS: SLSA provenance uploaded to $SLSA_REF"
          else
            echo "ATTEST_031: SLSA provenance upload failed"
            exit 1
          fi

          # Upload SBOM attestation
          SBOM_REF="${IMAGE_REF}/attestations:sbom-$COMMIT_SHA"
          echo "Uploading SBOM attestation..."

          if oras push "$SBOM_REF" \
            --annotation "org.opencontainers.image.title=SBOM Attestation" \
            --annotation "org.opencontainers.image.description=Software Bill of Materials attestation" \
            --annotation "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
            --annotation "org.opencontainers.image.revision=$COMMIT_SHA" \
            --annotation "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --annotation "keystone.attestation.type=sbom" \
            --annotation "keystone.attestation.format=cyclonedx" \
            --annotation "keystone.attestation.target=${{ steps.generate-provenance.outputs.container_target }}" \
            sbom-attestation.json:application/vnd.in-toto+json \
            sbom-attestation.json.bundle:application/vnd.dev.sigstore.bundle+json+v0.2; then
            echo "sbom_registry_ref=$SBOM_REF" >> $GITHUB_OUTPUT
            echo "PASS: SBOM attestation uploaded to $SBOM_REF"
          else
            echo "ATTEST_032: SBOM attestation upload failed"
            exit 1
          fi

          # Upload vulnerability attestation
          VULN_REF="${IMAGE_REF}/attestations:vulnerability-$COMMIT_SHA"
          echo "Uploading vulnerability attestation..."

          if oras push "$VULN_REF" \
            --annotation "org.opencontainers.image.title=Vulnerability Scan Attestation" \
            --annotation "org.opencontainers.image.description=Vulnerability scan results attestation" \
            --annotation "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
            --annotation "org.opencontainers.image.revision=$COMMIT_SHA" \
            --annotation "org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --annotation "keystone.attestation.type=vulnerability-scan" \
            --annotation "keystone.attestation.scanner=trivy" \
            --annotation "keystone.attestation.target=${{ steps.generate-provenance.outputs.container_target }}" \
            vulnerability-attestation.json:application/vnd.in-toto+json \
            vulnerability-attestation.json.bundle:application/vnd.dev.sigstore.bundle+json+v0.2; then
            echo "vuln_registry_ref=$VULN_REF" >> $GITHUB_OUTPUT
            echo "PASS: Vulnerability attestation uploaded to $VULN_REF"
          else
            echo "ATTEST_033: Vulnerability attestation upload failed"
            exit 1
          fi

          echo "All attestations stored successfully in OCI registry"

      - name: Verify attestations and source-to-artifact traceability
        id: verify-attestations
        run: |
          echo "Verifying attestations and establishing source-to-artifact traceability..."

          # Verify SLSA provenance signature
          echo "Verifying SLSA provenance attestation signature..."
          if cosign verify-blob \
              --certificate-identity="$OIDC_SUBJECT" \
              --certificate-oidc-issuer="$OIDC_ISSUER" \
              --bundle="slsa-provenance.json.bundle" \
              slsa-provenance.json; then
            echo "PASS: SLSA provenance signature verified"
            echo "slsa_verified=true" >> $GITHUB_OUTPUT
          else
            echo "ATTEST_041: SLSA provenance signature verification failed"
            exit 1
          fi

          # Verify SBOM attestation signature
          echo "Verifying SBOM attestation signature..."
          if cosign verify-blob \
              --certificate-identity="$OIDC_SUBJECT" \
              --certificate-oidc-issuer="$OIDC_ISSUER" \
              --bundle="sbom-attestation.json.bundle" \
              sbom-attestation.json; then
            echo "PASS: SBOM attestation signature verified"
            echo "sbom_verified=true" >> $GITHUB_OUTPUT
          else
            echo "ATTEST_042: SBOM attestation signature verification failed"
            exit 1
          fi

          # Verify vulnerability attestation signature
          echo "Verifying vulnerability attestation signature..."
          if cosign verify-blob \
              --certificate-identity="$OIDC_SUBJECT" \
              --certificate-oidc-issuer="$OIDC_ISSUER" \
              --bundle="vulnerability-attestation.json.bundle" \
              vulnerability-attestation.json; then
            echo "PASS: Vulnerability attestation signature verified"
            echo "vuln_verified=true" >> $GITHUB_OUTPUT
          else
            echo "ATTEST_043: Vulnerability attestation signature verification failed"
            exit 1
          fi

          # Verify source-to-artifact traceability
          echo "Verifying source-to-artifact traceability..."

          COMMIT_SHA="${{ github.sha }}"
          EXPECTED_ARTIFACT="${{ steps.generate-provenance.outputs.container_target }}"

          # Extract source commit from SLSA provenance
          PROVENANCE_COMMIT=$(jq -r '.predicate.buildDefinition.resolvedDependencies[0].digest.sha1' slsa-provenance.json)
          PROVENANCE_SUBJECT=$(jq -r '.subject[0].name' slsa-provenance.json)

          echo "Traceability verification:"
          echo "  Expected commit: $COMMIT_SHA"
          echo "  Provenance commit: $PROVENANCE_COMMIT"
          echo "  Expected artifact: $EXPECTED_ARTIFACT"
          echo "  Provenance subject: $PROVENANCE_SUBJECT"

          if [[ "$COMMIT_SHA" == "$PROVENANCE_COMMIT" ]]; then
            echo "PASS: Source commit traceability verified"
            echo "source_verified=true" >> $GITHUB_OUTPUT
          else
            echo "ATTEST_051: Source commit traceability verification failed"
            exit 1
          fi

          if [[ "$EXPECTED_ARTIFACT" == "$PROVENANCE_SUBJECT" ]]; then
            echo "PASS: Artifact traceability verified"
            echo "artifact_verified=true" >> $GITHUB_OUTPUT
          else
            echo "ATTEST_052: Artifact traceability verification failed"
            exit 1
          fi

          echo "PASS: End-to-end attestation verification and traceability established"

      - name: Upload attestation artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: slsa-attestations
          path: |
            slsa-provenance.json
            slsa-provenance.json.bundle
            sbom-attestation.json
            sbom-attestation.json.bundle
            vulnerability-attestation.json
            vulnerability-attestation.json.bundle
            build-metadata.json
            vuln-scan.json
          retention-days: 30

      - name: Generate SLSA attestation summary
        id: attestation-summary
        if: always()
        run: |
          echo "Generating comprehensive SLSA attestation summary..."

          # Count successful operations
          SUCCESS_COUNT=0
          TOTAL_OPERATIONS=6

          [[ "${{ steps.install-slsa-tools.outcome }}" == "success" ]] && SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          [[ "${{ steps.generate-provenance.outcome }}" == "success" ]] && SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          [[ "${{ steps.multi-predicate.outcome }}" == "success" ]] && SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          [[ "${{ steps.sign-attestations.outcome }}" == "success" ]] && SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          [[ "${{ steps.store-attestations.outcome }}" == "success" ]] && SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
          [[ "${{ steps.verify-attestations.outcome }}" == "success" ]] && SUCCESS_COUNT=$((SUCCESS_COUNT + 1))

          # Add to GitHub step summary
          {
            echo "# SLSA Provenance Attestation Results"
            echo ""
            echo "## Overall Status"
            if [[ $SUCCESS_COUNT -eq $TOTAL_OPERATIONS ]]; then
              echo "SUCCESS: All SLSA attestation operations completed successfully ($SUCCESS_COUNT/$TOTAL_OPERATIONS)"
            else
              echo "PARTIAL: $SUCCESS_COUNT/$TOTAL_OPERATIONS operations completed successfully"
            fi
            echo ""
            echo "## Component Results"
            echo "| Component | Status | Result |"
            echo "|-----------|--------|--------|"
            echo "| SLSA Tools Installation | ${{ steps.install-slsa-tools.outcome }} | $([ '${{ steps.install-slsa-tools.outcome }}' = 'success' ] && echo 'PASS' || echo 'FAIL') |"
            echo "| Build Metadata Collection | ${{ steps.build-metadata.outcome }} | $([ '${{ steps.build-metadata.outcome }}' = 'success' ] && echo 'PASS' || echo 'FAIL') |"
            echo "| SLSA Provenance Generation | ${{ steps.generate-provenance.outcome }} | $([ '${{ steps.generate-provenance.outcome }}' = 'success' ] && echo 'PASS' || echo 'FAIL') |"
            echo "| Multi-Predicate Attestations | ${{ steps.multi-predicate.outcome }} | $([ '${{ steps.multi-predicate.outcome }}' = 'success' ] && echo 'PASS' || echo 'FAIL') |"
            echo "| Attestation Signing | ${{ steps.sign-attestations.outcome }} | $([ '${{ steps.sign-attestations.outcome }}' = 'success' ] && echo 'PASS' || echo 'FAIL') |"
            echo "| OCI Registry Storage | ${{ steps.store-attestations.outcome }} | $([ '${{ steps.store-attestations.outcome }}' = 'success' ] && echo 'PASS' || echo 'FAIL') |"
            echo "| Attestation Verification | ${{ steps.verify-attestations.outcome }} | $([ '${{ steps.verify-attestations.outcome }}' = 'success' ] && echo 'PASS' || echo 'FAIL') |"
            echo ""
            echo "## Attestation Details"
            echo "- **Target Artifact**: ${{ steps.generate-provenance.outputs.container_target }}"
            echo "- **Build Time**: ${{ steps.build-metadata.outputs.build_time }}"
            echo "- **Source Commit**: ${{ steps.build-metadata.outputs.commit_sha }}"
            echo "- **Workflow Reference**: ${{ steps.build-metadata.outputs.workflow_ref }}"
            echo "- **Runner**: ${{ steps.build-metadata.outputs.runner_info }}"
            echo ""
            echo "## Registry References"
            echo "- **SLSA Provenance**: \`${{ steps.store-attestations.outputs.slsa_registry_ref }}\`"
            echo "- **SBOM Attestation**: \`${{ steps.store-attestations.outputs.sbom_registry_ref }}\`"
            echo "- **Vulnerability Attestation**: \`${{ steps.store-attestations.outputs.vuln_registry_ref }}\`"
            echo ""
            echo "## Verification Results"
            echo "- **SLSA Signature**: $([ '${{ steps.verify-attestations.outputs.slsa_verified }}' = 'true' ] && echo 'VERIFIED' || echo 'FAILED')"
            echo "- **SBOM Signature**: $([ '${{ steps.verify-attestations.outputs.sbom_verified }}' = 'true' ] && echo 'VERIFIED' || echo 'FAILED')"
            echo "- **Vulnerability Signature**: $([ '${{ steps.verify-attestations.outputs.vuln_verified }}' = 'true' ] && echo 'VERIFIED' || echo 'FAILED')"
            echo "- **Source Traceability**: $([ '${{ steps.verify-attestations.outputs.source_verified }}' = 'true' ] && echo 'VERIFIED' || echo 'FAILED')"
            echo "- **Artifact Traceability**: $([ '${{ steps.verify-attestations.outputs.artifact_verified }}' = 'true' ] && echo 'VERIFIED' || echo 'FAILED')"
            echo ""
            echo "## Artifacts"
            echo "- [SLSA Attestations](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (slsa-attestations artifact)"
            echo "- [Build Metadata](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) (build-metadata.json)"
            echo ""
            echo "## SLSA Compliance Level"
            if [[ $SUCCESS_COUNT -eq $TOTAL_OPERATIONS ]]; then
              echo "SLSA Level 3: Build integrity, source provenance, and cryptographic verification achieved"
            else
              echo "Partial Compliance: Some SLSA requirements not fully met"
            fi
          } >> $GITHUB_STEP_SUMMARY

          echo "success_count=$SUCCESS_COUNT" >> $GITHUB_OUTPUT
          echo "total_operations=$TOTAL_OPERATIONS" >> $GITHUB_OUTPUT